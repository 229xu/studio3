package com.aptana.editor.js.parsing;

import beaver.*;
import com.aptana.editor.js.parsing.ast.*;
import com.aptana.editor.js.parsing.lexer.JSTokens;

import java.io.IOException;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
public class JSParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAREN = 1;
		static public final short IDENTIFIER = 2;
		static public final short LCURLY = 3;
		static public final short LBRACKET = 4;
		static public final short MINUS = 5;
		static public final short PLUS = 6;
		static public final short PLUS_PLUS = 7;
		static public final short MINUS_MINUS = 8;
		static public final short STRING = 9;
		static public final short NUMBER = 10;
		static public final short THIS = 11;
		static public final short NEW = 12;
		static public final short NULL = 13;
		static public final short TRUE = 14;
		static public final short FALSE = 15;
		static public final short REGEX = 16;
		static public final short DELETE = 17;
		static public final short EXCLAMATION = 18;
		static public final short TILDE = 19;
		static public final short TYPEOF = 20;
		static public final short VOID = 21;
		static public final short FUNCTION = 22;
		static public final short SEMICOLON = 23;
		static public final short COMMA = 24;
		static public final short VAR = 25;
		static public final short WHILE = 26;
		static public final short FOR = 27;
		static public final short DO = 28;
		static public final short IF = 29;
		static public final short CONTINUE = 30;
		static public final short BREAK = 31;
		static public final short WITH = 32;
		static public final short SWITCH = 33;
		static public final short RETURN = 34;
		static public final short THROW = 35;
		static public final short TRY = 36;
		static public final short RPAREN = 37;
		static public final short ELSE = 38;
		static public final short LESS_LESS = 39;
		static public final short GREATER_GREATER = 40;
		static public final short GREATER_GREATER_GREATER = 41;
		static public final short LESS = 42;
		static public final short GREATER = 43;
		static public final short LESS_EQUAL = 44;
		static public final short GREATER_EQUAL = 45;
		static public final short INSTANCEOF = 46;
		static public final short IN = 47;
		static public final short RCURLY = 48;
		static public final short COLON = 49;
		static public final short RBRACKET = 50;
		static public final short EQUAL = 51;
		static public final short CASE = 52;
		static public final short DOT = 53;
		static public final short STAR = 54;
		static public final short FORWARD_SLASH = 55;
		static public final short PERCENT = 56;
		static public final short EQUAL_EQUAL = 57;
		static public final short EXCLAMATION_EQUAL = 58;
		static public final short EQUAL_EQUAL_EQUAL = 59;
		static public final short EXCLAMATION_EQUAL_EQUAL = 60;
		static public final short AMPERSAND = 61;
		static public final short CARET = 62;
		static public final short PIPE = 63;
		static public final short AMPERSAND_AMPERSAND = 64;
		static public final short STAR_EQUAL = 65;
		static public final short FORWARD_SLASH_EQUAL = 66;
		static public final short PERCENT_EQUAL = 67;
		static public final short PLUS_EQUAL = 68;
		static public final short MINUS_EQUAL = 69;
		static public final short LESS_LESS_EQUAL = 70;
		static public final short GREATER_GREATER_EQUAL = 71;
		static public final short GREATER_GREATER_GREATER_EQUAL = 72;
		static public final short AMPERSAND_EQUAL = 73;
		static public final short CARET_EQUAL = 74;
		static public final short PIPE_EQUAL = 75;
		static public final short QUESTION = 76;
		static public final short PIPE_PIPE = 77;
		static public final short DEFAULT = 78;
		static public final short FINALLY = 79;
		static public final short CATCH = 80;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGTuLCKMFZERHY2a9niII48QA4804HlT0XfwHtgN9Xr4YeKcWYAzzmu2zlBi8bPGx0q" +
		"BAWfsHDIdtdd$dJkRlI7PtLpsPedVsztlt7$AcV#SwJFPJK9K8vtrf74qdWR8vqtKbWPIN#" +
		"f7r$18kfRMKprQGnlOPtG1tK4hQ2DjfgqybiUmArb3rePTnMQnMzdDR0GRmFgoNgmxkvudq" +
		"dlqFa$XLNWgVKoVy6eydMVmwgm5My3ciqle6mgdxtaoT$8qNjMmpewpRzYtx0GxoNvYB$De" +
		"Ti1iZs8fZZr8DUWsUe0UyjlwK9vNr7e9TH$hkUxqer$M8tXDItL$ZghnDkwwqt$ziXx96$Y" +
		"gEtlHSzqP#MMz0h$2MztP2wXxCN$eQlXJb#h1UgnVrXDuKx$gdk2dzHPUw$wInxfVBEk#so" +
		"$hyVmQl#g#po$hYVmwhtN$tcFTBv5rVy0lwwcyjLzrVzGlwncyWzUw$#YnxfVAkZ$Xb$Ngl" +
		"BDVTN$QB#lPlBlNkf$nMFVBPTsVyyjwBkzvLjqdq5YQJFTIGxg26j5bT0$TJMEe4zr5ysa1" +
		"BQJwr82QK3DgGODWtR#LjYNlxvVrV$mSTOFyiSwPNzQVvZVw6dMobzMee#sqd6wbqTIV#b0" +
		"wh8VuPRqR7#5NtIluPRqh7#ENzSf#plU9PraFyTxsx3FsBdkVVSW#PaUfCeLwjavlwTRf0$" +
		"gGFjAjqr7wb3wZBqpMNPOwAqjFqIEc6VygFKgFyKaklzX8TXCRmyQn2MmISLTPriKeoxffJ" +
		"xfEFNxxbUtgWy8sERiF1lD9L8jcqIeQP6gFIAhah#rIz48TSfXi3h6j5ppFjJno244JM1mT" +
		"GviiOilO2hR4Q1FMsTKcx6wsaArYQzWw2gFFQHX5qndwYtwYRnbZeIoA9R8AB8zTO8r7$Ew" +
		"9nzq6ueofFIfQz7EaHtvZ1nh81hEXR1XxcttEZh6lACf3Urs9zghCDjZGzpxc7ysXslGLvT" +
		"ETjDOUYuLrIw4gXVFlTJM#3JkvB5V5$RHOwfKzassns9FJR1Xn1U2Pxf6dktotedPu6#rIm" +
		"7BeozBpYp7WlzxxYAF7wHdgWhVHtbFeQmzjrbWVSNJSXX5dOSU1HI$tsJAo#7F0BNevovMD" +
		"HMytvJAowELsN4OMlTo8owWV0pyx0cxHsqs$Z2nwkTsNaKKlD$eoikZb5bz65htStCl8efV" +
		"RUXbPz793BoEBWL$9lTp4oyQYjzjt6LdqSkCk8ujURjbbPD7BpRgCB5xerybw0czMobFeQ9" +
		"ufRk9nl2w$X5$0i$HJAB$o74xBJ#0q#wmDf#uNm7F21fuVmFEB3JodmFER3Jo$W#Tl$tbO2" +
		"7tE8cpWgGoUU1juai2JOWDF5V1Kjw6TZu7dGXlygGsUYspofuuD$jG3JtsR$BdO1dyQWETo" +
		"6$p904yp6$ov6ZpNsS2Zt$fj68Ui4$pfQ0DFL$3qiA6Tiy7JsmQUNF3qiw5UcxtFzzBkN#m" +
		"WpsIlUTw$Iirp23nl#ByFiYEern4RwlK6$3baGxr#iAbzJeFdj0qyluBdD$zvU1Xu3lhF8u" +
		"xnJ4gmWUSBdicpRU3v7EUnpspW#HGyHstW#GGy7zl0yn5uFhI1vmFml6y3ptlWUTS6ddVGx" +
		"pLiu7aHFBLic1SNWIVV1dyU0ayzZpp5VmhjzF2PR1kwdwfIigKI7S#nXF5JSlaK3z9rl24j" +
		"DgVH3g#VE5n4xItPV380zTgdbs0RbV#zM9fuW2RI4Tw8RIrIivuKGpVOuekhFURI7f#VpzI" +
		"aau7eLx6MfHhrP5cyEVrgwIQjiKtqHq2yl9jLTNafxcTxh7Z98jacjZCGNh8fR2gRRdnY9V" +
		"QpYfQyV5ZiOz41cSdIFpQRpMNpn5wMRCdBFyHzB3lWwyqULiFIjpKk4xlPjO7safrcxInvs" +
		"KxiOli3tfOxsNyiUTbNx62F1SJBeHGkFtClq9$i6KihKGUndMa1yLBty6rwXu#YNJIL$MN9" +
		"orje9#S1MOagKG5BPpMfG6p5kXvkQOxNPdLvfO1ukP4TP9ci2Ml4Ck1bZgMsH3$msW7hSMD" +
		"S5eXjlBwbjcp9slE0h4Ji3dORsyRkWvU4jhpAKblYnHi7fiVXtGxs47kUROUNrrlsiaj0l7" +
		"mIi#SxzWhxdPs2pOwMlUmH22zvA1DKm1CeZlq2cuCjUpaW85ucOQri2J$RikTXSvXbBsygO" +
		"o#Jf9TTuM4VTeeFqUSFB#cxOPuPqYpRR6svH6$B9MPOBh7KSeczbalyntA9vosNE62vnBjM" +
		"Ix0hB9TeQhb4Srd2sdpPRr5$6MGHn4gf9UTaPRUbCl$GVUndI#VKIp5lUrcouV46pcwd7ZO" +
		"npIHX0rDJZ0zYUsrWQYwP7h61wIh9z9GDJFCaqvysCAtJcRYrqLmY4viZcIwtWUbEoTJA1g" +
		"Qx95Dx6vZkaKpTR62wLpBriu5fiMGQQeafg1lKBM#wfVwDAjQuNFWRr0tg1dM3ka7Te6vGD" +
		"wWRr0tgdkEPbhKkfMPMwVHOIT#wAFexkgNXoIcD5kl3ylb8KY$UczKYKh#ZUzX$BrZ$S#DW" +
		"IwcUzE9DdpPkzy2mNFvqvJXxooV3Wpur7lQbmNoE5JR4fyQDFZM6#zSZVkRFPkzupL$Dll2" +
		"MpsvXN$eveYxqaJ$Jg$rfpDDlEhlAh$IHlyb7$XOV#Tjyr7#KZ$pHFlB7#iZtzRl$4ttaJ$" +
		"QH$vwF$0zyv7$a8$yJ7$cVUkt$6VhV7w3kMEP6iMiAzu4HChMWs3vGGCFbaZY91Z472qUyE" +
		"wkE5QKjVITBF48tyeg8LwFJzAB#bqJOfUmonbaO7wSNOwsGghyEqalqChr2hz9hz3eTeiFq" +
		"1htf8VL5#HSIEj3DP7vPvod#Uj73AhaIBLCoHydwgw5VSivQZpbwwtVNlqL0xUIpw9leJnP" +
		"3HvYJxMBtiyVPi#nlxk0HF8h7bw2jol1SNeTVp9lmgta1xyHlu0FvS3wQJw0kr9uwK4Vrx4" +
		"ITaTALki5#3xg1Ub8lwarzuDi5M4jgqKLKc#hGCFJq21f9e#3vQ8o1iUetwoQYxoUZBwRGB" +
		"JILfj5qce5TzJRiE7TWfPb5isaEpQKxYQinSpV6a65t8SRL8bfCIsWfBSCkkwA8lMHoqaQS" +
		"F2x72UHAlwspOjO3MVST5kjUGArjhBlZlDPzPodgxjaV#qTTUHlpPLVt3UUrxlNFQzrNdzU" +
		"wDpslTMzoNklU#BpMlL4nwmopq44X54fX54uHL84YgI9LeYYgJD4Ke$#LMegd14ga9B#jhp" +
		"glrekFklDRTr#ZhX$fzzw1D8W6$yjRllWw7qZhnUTx9miptb$hnItn8ZDUh$cQGYtpIhEzX" +
		"BBtstRgQLpO1ouhP$V13lYLHpMe9lh0xPS3VjdL9jvwOOt9viuow8NYSssDVk6oC2wJQR#y" +
		"mwNAxp1MetJAe4ogJbcKRP77uP77tExkSBv5VkwHtsWNrvXoONuPxa2bM$lqUgsdIwWXNMg" +
		"JHLVTzDPoppzZV1js6i6Y4G$4Q3DMzlKMUtAR3IFE2PwwNdZqTuXy6#tYXBQL4LSN$FLyZB" +
		"Xjr42#ZVQ#Bm0ZBf0xJj1Yq6BGOj1Yq6BGOj1Yq6BGebqMhPr2lProhV1ulZzPus4syEI2f" +
		"ueDF0myoJRns56lP1lziQFVTPwzDl0umBFI9fvXDl2q1S#MSkGFisb#wVxasC0p33ohRU1f" +
		"QjCuN6LJ##Z#D2b7$goooP$6u6bi0qyZy3IoQPstOxwl1azJ6tYQbBFsQMnJlzUrgNsuJUD" +
		"vBNZgsy1JnwRr9zUcUkNQU6x93VByN$AKf$Egz$5ivJFP8JIKRWn82UEdvCOpb#R1$wr5ql" +
		"Ruu9nNJkkrKldlf7MoNXjGiyr5QfP3ksYVpRviBGLVO5eib$9LFI$6VZRFucT1RSw3bxdbr" +
		"alp9tdMlSmDa9U6V#NTo#BhJNdtalyhl2o$RQbxfNlab4zhNjOBc9UwD$htdkj0d1Qzp8UV" +
		"WV5Izp1VFdEnObhpiYsr2v2NAt7Bo9VVf5vdsKjZZ0IgnurnwRGyU#e5hCTrRsIF2s6rBGL" +
		"UWUfnM3B6fUKU3w2Nkd$wg3HQixnwkLRwgSkcSkoboyVotPPdUra#xoh14lz$9IpD5unWY$" +
		"gGUX1hUzevMR5uwjI$lMUf16nOA#6jBtBA6nDg5sGACWMPp4n1tQ1kUTEriiEN1t#3ka7Te" +
		"6vGDwWRr0tg1dM3ka7TSp$JbbRJBhtIyPHEQmkj5Uf5csWtdgxVqRN3YtFdCBpmRSFRlLhd" +
		"y8FXNwTHjlaBopZ$VFjVrlQ3#UStNr$l6LO5ZlNVjGyuPQgps3xWf1ov8kPW7#1uwp$xrp$" +
		"53K6ANe83wo2#6LXVbjPJzUz9rf7b6b1zYSseERMWg#XgkeQkfPRKYgwZwpsarfSS3IXVc5" +
		"xMUKIn5vWzjqp9p9xrpoM7oMyHXCXdaRTiuHpQ89z5txkAQnSfKzAx0H6VVAlyWudX5nE5$" +
		"gM7NO9NG$dt88b#DU9XwGhRkdNOM3mkL#7x5Mf4Zl5kdRpht677Wuhx3eHFoV$xHY6ZWVk0" +
		"4FuJVFaMUNM88ZAXbmhiWKuv0LmC7ti1NuSF$o6g40fS06pivgymIU5#XISCZAoky0Q5InG" +
		"UCh1YcC8cgex7LRjCLUcJ4HwbmggUZbr8cuRuIQAaWMuVGiSWVJhgizMTbhhImFZr1bRACZ" +
		"1akwbSVNSu2UqUEa#r7zeY3FsJbmwy1ZB8fQTyVSeSL$mzeQ$gdDTUSJwkxDI2VqsWizI8q" +
		"qhapG2YlPFU0jyXekGSX2S0KU#mvu2ldMsZgBrKhh1AqNGQGkIi1evtWMYN9BqTMoDym5JN" +
		"WqGfoKX7NwOCGnjb45MT0io2N83ynnHt0uMjI$QXwa8yrWEt0Ry6tqZKSJ$a0SWxI7#oU9c" +
		"eK5KMzQxq1$1RR$NqtWP9ZoWkxTpAXtTJEFSi7z46rHBGZnV2nzSGpmF#fFBY8PZ7KPX3rQ" +
		"2NLn$XdYfl2TAQ8krjX1kgj6LeF$H9mkN0fn5Nyo7lMfM$ISLRglWM0nCM69WShj8$0NSNw" +
		"A5TesQejBsGpKQuCgJQ2EI$Xx0QXmaX2hkgzlfPSRPmrxNQxQW$UADUWdo7#0haHofEZFsa" +
		"7u3LLFnkTxdA3q4UXZm2US#TdjVPnBrNsQk1y07eVG7y6OXrA3tCLAQsWUbfq5NhIFJL2ci" +
		"YlHuGSoZlUeHRGaUj1z4BJ1pGoJlXZaUFXsvlu78LnvnBHrhqan3qG$eyp4lqSLXZX3TW3H" +
		"q0H5qOV4p7UiVx08y1Zq8l3c6CrVYBY3BGqF6ODndPmEL0z6lyAc0xj3FoCWO3#q4m1pAcm" +
		"bVOoLW4V0Qu0uYvxGHV1dn8mBp9G7ycd87yYV19mzTCLOVC95TzLBoMmkOArVZDLEjavao5" +
		"gnIgjimygF2JedpHtwCleY4OmybgtNPUgThpVQIhSUDqOEn#YVWjAky3XDMwwiJOIVYSA2q" +
		"2QI#e$0yH$aRbeuvfQBVeYYhl8uJhA7zEcVeFws$r25Lc7C9Oms9WjphMuPXSu7L0Z8NgVO" +
		"45m8dek#R0#LZJCUQhRo9Ax0Py37W3y31mD$0h8EP9zVy2iKycCQAi6FGfnaOMU4CnthEk1" +
		"5SLI0O4wrTC6mZsoHZCyQmEG8oFhA66Rp7O4sD#XO$OYs9#KsdOFxEc6#54j6KQoaHtLFNw" +
		"666rHphXGnhg6RrQvM5EHpzZX6CnThAmVkHXl4L$gVBXNnRiv7qA6#55#oxs2WZ6cVDl8CP" +
		"g2jea5djyx2p8TiXE2DQkMEmjiTZZOtyXYiFQ5PS8mJaZxZ88sYbsDcmy2nkOvp5Ox#Amty" +
		"Uq1M9$Ya4$n66inxqC7RHntey8Ozx7OQs8GpWBuoSFt36O1$5O8#FHRgbmBn6SQMkGZZD3F" +
		"Deh7fZDeOkv7$CPnaiK1ECb5lsRWFxCWs#nA9#0kPC2ZZJCaLZCzOJ7aOUr8XPzaO3z8WLp" +
		"B15ZA#quqi2RM0dvw8lOHn76$fcYxqKL4KUR9w9DyauZB1367fW8$rCsel#nZbJDX$$OwnB" +
		"HFdc$8Nmjqd6sITcClCw83qSSuoyFypBk7eJrVHHZ8Dk9jD#HzY3Y$o1S5scrWLWRuZ1Vah" +
		"Uu#oTaDSPMZhdFZ7IStedcAnqrHq9xk$FZKzrXri4TJYamfRzhIX$f3Zk#C33ii87P5HGsK" +
		"tRKMXY$pi2S#rHSxJ6X$PMFPqosnYiyPI0VhV17PKlDvN0rFr9tAbG#fFxgub8#nXeOTy1K" +
		"XzccVBHttD6YPKAmHZeE5qsBJouQJrblZfyjuC2w4whsiT01tdHBBX#Vxmw7HnRD2zkcV7Z" +
		"CdPQjpYOvJoaSgNZkCJ3DwTrUt6x5UQHuNivHXTFSQMcDpjBvGU4$1kP6bL2dLih6oP9zo7" +
		"vVOObdDA8g3i$#LqbJsC1RFKiZu6XpRkN2r9a$l6S9TP#e8#uv#vIEEfk77pRfx2#Xt2i6H" +
		"XIkn#30Nf#WhsKulqGqBPrl2LrAIBj9ST$iJejum9IlvbPKP#LB5GDp7p8mwGELRpgd9Jol" +
		"sWBtamYSxnB#TkT5uQoJZJDGr6j6l7BDadsjlDWK7kWELndY3bTJTwSgjofSQIgZnd9YOid" +
		"yMQUL7jRonBObwuHW7uW#QyvdLpqhtiaKdcaA$sbWZZhNvgGghENMoQsgy2A5ZHIsLjXBeM" +
		"czpL5dz1nrfyqzvCvBxQFGv4UQMb$JvYZSKzJ$j2CApnXOLVcPhTQNx9SCpEkXSAn2TH$8c" +
		"s$cCzB2bk9EdeszIN57czRQ2htSuSIXY2ypvRrXojFFLjZ38oFSQP7DJFdOGoEdcF9SFtFO" +
		"wqwBnZcGcTexH9qVmrGxPTTLgFQRx6K6vhZwOPf2rUQvQnMgFIoty4wECghFSbIVvQmzkrt" +
		"SkcoNWRo6Eyqvpi2OgUuqhleW2UUq9Dn18hztvrNCSOUJS2QhQDhFAoutvQbpNyKt5VyMfA" +
		"cvMwb2ST#CVlPNO4FkrLYdr9vDQenNQkxMIGulNYvPdHjeX3kDS7PAxW71MPLsctHLFz19T" +
		"nghQGeFDUb#WxZfvp3ik3lir0LtAcvgKpxGbDyHySscl6C6Pglznhd0k7CuCjqwZhwcyfyZ" +
		"ljwKzwafJwqJ8MejICAPBgM#IklfrkEJZQeAJVmj$b9XdEq5rYznIlmYupZhYZS4JfZYLUq" +
		"ZqLwq4pXLQnzgiA$X$AhXxAnXJTDmTjHmBn4uoueC2ExA0cTASOd02LZWrYDQGJ3Y14wf0Z" +
		"ToSJNaAaWBI7CmTnQTH5zf4sTUxMNjQp58naPeEAVhOJ5S3CEpEmGt9D5L#qwC4YErNyGSC" +
		"Ljg$ac5B$6RE2t#q7uNiyHCSOUuNQRT1fa06Qzqnceu$GgSj4Kw12TtWHkUQA0zhpsdFQiz" +
		"epsjFOKu6alC45F4987pli1vMkIAEdXUB1eAtEH4LGXsJ94gCl6S3fa6cIecYvl5H74Bmf6" +
		"G2YRVneakOg3031EzZHJjC#qTxMtjBUs8zgRsXdPOEwIzhhsclQgz8d3$4xYRQ0V5Z#87yR" +
		"tuJfmK9yItuXjnN7mjlXAupugt8M#98zgBP7g9buh43XI6NZ2bFW$1x1MuCGYiZW8t2x41i" +
		"hvGOvsOYUSzXN7SXmJk168L1FSbiKmibUcBnIA92#HplfY7vrnnLs6vExKFH1lHMk1#fxsl" +
		"uIQeVQNgVbHq51r4Jwc5cvpeeQ5EsaanGAPWFHT3H2zz18Z1ehzs0da$YnirlKtEQ5YnjRy" +
		"rZ5qH3Wc3uFuZGWHkPI85WcaeaY594DmOHOB0$LXW7n6uDudg0hSjWTkYk43WFYNgGN0N4l" +
		"cYlcW6R0ff0caCQGJ1$LhWlYemhmNkdU9IyQR0#Y7k5GlnN0bP8Nr#JjNvMVbyfh0DdfRFf" +
		"rJiIVd4VgGTqDuJxO7lQhX9QySWk8bhk9bgkFbf#ep4hLF4GM8XkFKBtBv4PO5xi60GlHM5" +
		"S6X$QhzgFsZVg7RzMFj2MJeaNi7pPHLxGZuVLx77vFDHyRgAFwnx8aEFQ2#8WwPLu2SPaYD" +
		"GXamZqDFBFUeyQipqfN5kBrTz46fV6C9iPoteVcAqdJY4qHebdIY4kf43mcW7ydOWl5yAev" +
		"s8xqHuECB39N8LBhtS9KN$FpnSXKilmr1c6Cgk1#f$JNiNmhk0cu2RW1kaE6WjS2rm2eL3G" +
		"ca#y1OfeP0m5TObmeIwL32XBf65#Gk02r1#0SeROLqYJAXB1HFg4bcOFnK#JuLFqu3JWDE1" +
		"qu4pm7atv3R8NgJjHPeX8Kf2QHtIr#cV1o9z9T8s8xuPuLiXzq1kXznHA26q6sMsGAShokZ" +
		"IlfWug2FoEqhK9GGIIdkGjmVfUv2s1sbR4TwAj2x0BaYxJqeeRKEQIpeNIWZ48MKKugCG7o" +
		"N33kgEkFw$46O1Pm5lA9GGY8DkGjYG48Y3LY6y2hXF2gCUIaOgwIM5IvcDy6o9d7eYt5EYT" +
		"va3lJaIlKjlwFM63ouPZVXeYORqGRoFH0UDGNYCH0VrHRYlH4F68ZvMeY7z4EydiRYCGzuu" +
		"YSLb8V8MIYmg$P7UNw9RnYDjl4Itt8kqUoMwPO0KHXE04u2BW8k00u43WHE14u6BWOk1Wu2" +
		"3W9E0au1BW4k0Wu7wD#qd0oS3bmAN0eS2Xm9704S0bm6N0M#K4afpWNE1Au0hW4E0Gw2Z$$" +
		"rF$VzrBGSk1wu6Mf5vAAF$5kpDm9k16u4RWHqyoCp$0K5sqVe=");

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN10 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 10];
		}
	};

	private final Action[] actions;

	public JSParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] Program = SourceElements
			new Action() {	// [1] SourceElements = SourceElements SourceElement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [2] SourceElements = SourceElement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [3] SourceElement = FunctionDeclaration
			Action.RETURN,	// [4] SourceElement = Statement
			RETURN4,	// [5] FunctionDeclaration = FUNCTION IDENTIFIER FunctionParameters FunctionBody; returns 'FunctionBody' although none is marked
			RETURN3,	// [6] FunctionExpression = FUNCTION FunctionParameters FunctionBody; returns 'FunctionBody' although none is marked
			Action.RETURN,	// [7] FunctionExpression = FunctionDeclaration
			RETURN2,	// [8] FunctionParameters = LPAREN RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [9] FunctionParameters = LPAREN FormalParameterList RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [10] FormalParameterList = FormalParameterList COMMA IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [11] FormalParameterList = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN2,	// [12] FunctionBody = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [13] FunctionBody = LCURLY SourceElements RCURLY; returns 'RCURLY' although none is marked
			Action.RETURN,	// [14] Statement = Block
			RETURN3,	// [15] Statement = VAR VariableDeclarationList SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [16] Statement = Expression_NoLBF SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [17] Statement = IfStatement
			Action.RETURN,	// [18] Statement = IterationStatement
			Action.RETURN,	// [19] Statement = ContinueStatement
			Action.RETURN,	// [20] Statement = BreakStatement
			Action.RETURN,	// [21] Statement = ReturnStatement
			Action.RETURN,	// [22] Statement = WithStatement
			Action.RETURN,	// [23] Statement = LabelledStatement
			Action.RETURN,	// [24] Statement = SwitchStatement
			Action.RETURN,	// [25] Statement = ThrowStatement
			Action.RETURN,	// [26] Statement = TryStatement
			Action.RETURN,	// [27] Statement = SEMICOLON
			new Action() {	// [28] Statement = error
				public Symbol reduce(Symbol[] _symbols, int offset) {
					return new JSErrorStatementNode();
				}
			},
			Action.RETURN,	// [29] Statement_NoIf = Block
			RETURN3,	// [30] Statement_NoIf = VAR VariableDeclarationList SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [31] Statement_NoIf = Expression_NoLBF SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [32] Statement_NoIf = IfStatement_NoIf
			Action.RETURN,	// [33] Statement_NoIf = IterationStatement_NoIf
			Action.RETURN,	// [34] Statement_NoIf = ContinueStatement
			Action.RETURN,	// [35] Statement_NoIf = BreakStatement
			Action.RETURN,	// [36] Statement_NoIf = ReturnStatement
			Action.RETURN,	// [37] Statement_NoIf = WithStatement_NoIf
			Action.RETURN,	// [38] Statement_NoIf = LabelledStatement_NoIf
			Action.RETURN,	// [39] Statement_NoIf = SwitchStatement
			Action.RETURN,	// [40] Statement_NoIf = ThrowStatement
			Action.RETURN,	// [41] Statement_NoIf = TryStatement
			Action.RETURN,	// [42] Statement_NoIf = SEMICOLON
			new Action() {	// [43] Statement_NoIf = error
				public Symbol reduce(Symbol[] _symbols, int offset) {
					return new JSErrorStatementNode();
				}
			},
			RETURN2,	// [44] Block = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [45] Block = LCURLY StatementList RCURLY; returns 'RCURLY' although none is marked
			new Action() {	// [46] StatementList = StatementList Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [47] StatementList = Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [48] VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [49] VariableDeclarationList = VariableDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [50] VariableDeclarationList_NoIn = VariableDeclarationList_NoIn COMMA VariableDeclaration_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [51] VariableDeclarationList_NoIn = VariableDeclaration_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [52] VariableDeclaration = IDENTIFIER
			RETURN3,	// [53] VariableDeclaration = IDENTIFIER EQUAL AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [54] VariableDeclaration_NoIn = IDENTIFIER
			RETURN3,	// [55] VariableDeclaration_NoIn = IDENTIFIER EQUAL AssignmentExpression_NoIn; returns 'AssignmentExpression_NoIn' although none is marked
			RETURN7,	// [56] IfStatement = IF LPAREN Expression RPAREN Statement_NoIf ELSE Statement; returns 'Statement' although none is marked
			RETURN5,	// [57] IfStatement = IF LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [58] IfStatement_NoIf = IF LPAREN Expression RPAREN Statement_NoIf ELSE Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [59] IterationStatement = DO Statement WHILE LPAREN Expression RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [60] IterationStatement = WHILE LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN6,	// [61] IterationStatement = FOR LPAREN SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [62] IterationStatement = FOR LPAREN SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [63] IterationStatement = FOR LPAREN SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [64] IterationStatement = FOR LPAREN SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [65] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [66] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [67] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [68] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [69] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [70] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [71] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN10,	// [72] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [73] IterationStatement = FOR LPAREN LeftHandSideExpression IN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [74] IterationStatement = FOR LPAREN VAR VariableDeclaration_NoIn IN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [75] IterationStatement_NoIf = DO Statement WHILE LPAREN Expression RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [76] IterationStatement_NoIf = WHILE LPAREN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN6,	// [77] IterationStatement_NoIf = FOR LPAREN SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [78] IterationStatement_NoIf = FOR LPAREN SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [79] IterationStatement_NoIf = FOR LPAREN SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [80] IterationStatement_NoIf = FOR LPAREN SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [81] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [82] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [83] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [84] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [85] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [86] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [87] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN10,	// [88] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [89] IterationStatement_NoIf = FOR LPAREN LeftHandSideExpression IN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [90] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclaration_NoIn IN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			new Action() {	// [91] ContinueStatement = CONTINUE.c SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol c = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSTokens.CONTINUE, c.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [92] ContinueStatement = CONTINUE.c IDENTIFIER.i SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol s = _symbols[offset + 3];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSTokens.CONTINUE, i, c.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [93] BreakStatement = BREAK.b SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSTokens.BREAK, b.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [94] BreakStatement = BREAK.b IDENTIFIER.i SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol s = _symbols[offset + 3];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSTokens.BREAK, i, b.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			RETURN2,	// [95] ReturnStatement = RETURN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [96] ReturnStatement = RETURN Expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [97] WithStatement = WITH LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN5,	// [98] WithStatement_NoIf = WITH LPAREN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN5,	// [99] SwitchStatement = SWITCH LPAREN Expression RPAREN CaseBlock; returns 'CaseBlock' although none is marked
			RETURN2,	// [100] CaseBlock = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [101] CaseBlock = LCURLY CaseClauses RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [102] CaseBlock = LCURLY DefaultClause RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [103] CaseBlock = LCURLY DefaultClause CaseClauses RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [104] CaseBlock = LCURLY CaseClauses DefaultClause RCURLY; returns 'RCURLY' although none is marked
			RETURN5,	// [105] CaseBlock = LCURLY CaseClauses DefaultClause CaseClauses RCURLY; returns 'RCURLY' although none is marked
			new Action() {	// [106] CaseClauses = CaseClauses CaseClause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [107] CaseClauses = CaseClause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [108] CaseClause = CASE Expression COLON; returns 'COLON' although none is marked
			RETURN4,	// [109] CaseClause = CASE Expression COLON StatementList; returns 'StatementList' although none is marked
			RETURN2,	// [110] DefaultClause = DEFAULT COLON; returns 'COLON' although none is marked
			RETURN3,	// [111] DefaultClause = DEFAULT COLON StatementList; returns 'StatementList' although none is marked
			RETURN3,	// [112] LabelledStatement = IDENTIFIER COLON Statement; returns 'Statement' although none is marked
			RETURN3,	// [113] LabelledStatement_NoIf = IDENTIFIER COLON Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN3,	// [114] ThrowStatement = THROW Expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [115] TryStatement = TRY Block Catch; returns 'Catch' although none is marked
			RETURN3,	// [116] TryStatement = TRY Block Finally; returns 'Finally' although none is marked
			RETURN4,	// [117] TryStatement = TRY Block Catch Finally; returns 'Finally' although none is marked
			RETURN5,	// [118] Catch = CATCH LPAREN IDENTIFIER RPAREN Block; returns 'Block' although none is marked
			RETURN2,	// [119] Finally = FINALLY Block; returns 'Block' although none is marked
			Action.RETURN,	// [120] PrimaryExpression = PrimaryExpression_NoLBF
			Action.RETURN,	// [121] PrimaryExpression = ObjectLiteral
			new Action() {	// [122] PrimaryExpression_NoLBF = THIS.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					return new JSPrimitiveNode(JSTokens.THIS, t.getStart(), t.getEnd());
				}
			},
			new Action() {	// [123] PrimaryExpression_NoLBF = IDENTIFIER.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					return new JSPrimitiveNode(t, _symbol_t.getStart(), _symbol_t.getEnd());
				}
			},
			Action.RETURN,	// [124] PrimaryExpression_NoLBF = Literal
			Action.RETURN,	// [125] PrimaryExpression_NoLBF = ArrayLiteral
			RETURN3,	// [126] PrimaryExpression_NoLBF = LPAREN Expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [127] ArrayLiteral = LBRACKET RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [128] ArrayLiteral = LBRACKET Elision RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [129] ArrayLiteral = LBRACKET ElementList RBRACKET; returns 'RBRACKET' although none is marked
			RETURN4,	// [130] ArrayLiteral = LBRACKET ElementList COMMA RBRACKET; returns 'RBRACKET' although none is marked
			RETURN5,	// [131] ArrayLiteral = LBRACKET ElementList COMMA Elision RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [132] ElementList = AssignmentExpression
			RETURN2,	// [133] ElementList = Elision AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN3,	// [134] ElementList = ElementList COMMA AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN4,	// [135] ElementList = ElementList COMMA Elision AssignmentExpression; returns 'AssignmentExpression' although none is marked
			new Action() {	// [136] Elision = Elision COMMA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [137] Elision = COMMA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [138] ObjectLiteral = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [139] ObjectLiteral = LCURLY PropertyNameAndValueList RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [140] PropertyNameAndValueList = PropertyName COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN5,	// [141] PropertyNameAndValueList = PropertyNameAndValueList COMMA PropertyName COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [142] PropertyName = IDENTIFIER
			Action.RETURN,	// [143] PropertyName = STRING
			Action.RETURN,	// [144] PropertyName = NUMBER
			Action.RETURN,	// [145] MemberExpression = PrimaryExpression
			Action.RETURN,	// [146] MemberExpression = FunctionExpression
			RETURN4,	// [147] MemberExpression = MemberExpression LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [148] MemberExpression = MemberExpression DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [149] MemberExpression = NEW MemberExpression Arguments; returns 'Arguments' although none is marked
			Action.RETURN,	// [150] MemberExpression_NoLBF = PrimaryExpression_NoLBF
			RETURN4,	// [151] MemberExpression_NoLBF = MemberExpression_NoLBF LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [152] MemberExpression_NoLBF = MemberExpression_NoLBF DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [153] MemberExpression_NoLBF = NEW MemberExpression Arguments; returns 'Arguments' although none is marked
			Action.RETURN,	// [154] NewExpression = MemberExpression
			RETURN2,	// [155] NewExpression = NEW NewExpression; returns 'NewExpression' although none is marked
			Action.RETURN,	// [156] NewExpression_NoLBF = MemberExpression_NoLBF
			RETURN2,	// [157] NewExpression_NoLBF = NEW NewExpression; returns 'NewExpression' although none is marked
			RETURN2,	// [158] CallExpression = MemberExpression Arguments; returns 'Arguments' although none is marked
			RETURN2,	// [159] CallExpression = CallExpression Arguments; returns 'Arguments' although none is marked
			RETURN4,	// [160] CallExpression = CallExpression LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [161] CallExpression = CallExpression DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [162] CallExpression_NoLBF = MemberExpression_NoLBF Arguments; returns 'Arguments' although none is marked
			RETURN2,	// [163] CallExpression_NoLBF = CallExpression_NoLBF Arguments; returns 'Arguments' although none is marked
			RETURN4,	// [164] CallExpression_NoLBF = CallExpression_NoLBF LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [165] CallExpression_NoLBF = CallExpression_NoLBF DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [166] Arguments = LPAREN RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [167] Arguments = LPAREN ArgumentList RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [168] ArgumentList = ArgumentList COMMA AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [169] ArgumentList = AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [170] LeftHandSideExpression = NewExpression
			Action.RETURN,	// [171] LeftHandSideExpression = CallExpression
			Action.RETURN,	// [172] LeftHandSideExpression_NoLBF = NewExpression_NoLBF
			Action.RETURN,	// [173] LeftHandSideExpression_NoLBF = CallExpression_NoLBF
			Action.RETURN,	// [174] PostfixExpression = LeftHandSideExpression
			RETURN2,	// [175] PostfixExpression = LeftHandSideExpression PLUS_PLUS; returns 'PLUS_PLUS' although none is marked
			RETURN2,	// [176] PostfixExpression = LeftHandSideExpression MINUS_MINUS; returns 'MINUS_MINUS' although none is marked
			Action.RETURN,	// [177] PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF
			RETURN2,	// [178] PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF PLUS_PLUS; returns 'PLUS_PLUS' although none is marked
			RETURN2,	// [179] PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF MINUS_MINUS; returns 'MINUS_MINUS' although none is marked
			Action.RETURN,	// [180] UnaryExpression = PostfixExpression
			RETURN2,	// [181] UnaryExpression = DELETE UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [182] UnaryExpression = EXCLAMATION UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [183] UnaryExpression = MINUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [184] UnaryExpression = MINUS_MINUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [185] UnaryExpression = PLUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [186] UnaryExpression = PLUS_PLUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [187] UnaryExpression = TILDE UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [188] UnaryExpression = TYPEOF UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [189] UnaryExpression = VOID UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [190] UnaryExpression_NoLBF = PostfixExpression_NoLBF
			RETURN2,	// [191] UnaryExpression_NoLBF = DELETE UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [192] UnaryExpression_NoLBF = EXCLAMATION UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [193] UnaryExpression_NoLBF = MINUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [194] UnaryExpression_NoLBF = MINUS_MINUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [195] UnaryExpression_NoLBF = PLUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [196] UnaryExpression_NoLBF = PLUS_PLUS UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [197] UnaryExpression_NoLBF = TILDE UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [198] UnaryExpression_NoLBF = TYPEOF UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN2,	// [199] UnaryExpression_NoLBF = VOID UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [200] MultiplicativeExpression = UnaryExpression
			RETURN3,	// [201] MultiplicativeExpression = MultiplicativeExpression STAR UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN3,	// [202] MultiplicativeExpression = MultiplicativeExpression FORWARD_SLASH UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN3,	// [203] MultiplicativeExpression = MultiplicativeExpression PERCENT UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [204] MultiplicativeExpression_NoLBF = UnaryExpression_NoLBF
			RETURN3,	// [205] MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF STAR UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN3,	// [206] MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF FORWARD_SLASH UnaryExpression; returns 'UnaryExpression' although none is marked
			RETURN3,	// [207] MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF PERCENT UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [208] AdditiveExpression = MultiplicativeExpression
			RETURN3,	// [209] AdditiveExpression = AdditiveExpression PLUS MultiplicativeExpression; returns 'MultiplicativeExpression' although none is marked
			RETURN3,	// [210] AdditiveExpression = AdditiveExpression MINUS MultiplicativeExpression; returns 'MultiplicativeExpression' although none is marked
			Action.RETURN,	// [211] AdditiveExpression_NoLBF = MultiplicativeExpression_NoLBF
			RETURN3,	// [212] AdditiveExpression_NoLBF = AdditiveExpression_NoLBF PLUS MultiplicativeExpression; returns 'MultiplicativeExpression' although none is marked
			RETURN3,	// [213] AdditiveExpression_NoLBF = AdditiveExpression_NoLBF MINUS MultiplicativeExpression; returns 'MultiplicativeExpression' although none is marked
			Action.RETURN,	// [214] ShiftExpression = AdditiveExpression
			RETURN3,	// [215] ShiftExpression = ShiftExpression LESS_LESS AdditiveExpression; returns 'AdditiveExpression' although none is marked
			RETURN3,	// [216] ShiftExpression = ShiftExpression GREATER_GREATER AdditiveExpression; returns 'AdditiveExpression' although none is marked
			RETURN3,	// [217] ShiftExpression = ShiftExpression GREATER_GREATER_GREATER AdditiveExpression; returns 'AdditiveExpression' although none is marked
			Action.RETURN,	// [218] ShiftExpression_NoLBF = AdditiveExpression_NoLBF
			RETURN3,	// [219] ShiftExpression_NoLBF = ShiftExpression_NoLBF LESS_LESS AdditiveExpression; returns 'AdditiveExpression' although none is marked
			RETURN3,	// [220] ShiftExpression_NoLBF = ShiftExpression_NoLBF GREATER_GREATER AdditiveExpression; returns 'AdditiveExpression' although none is marked
			RETURN3,	// [221] ShiftExpression_NoLBF = ShiftExpression_NoLBF GREATER_GREATER_GREATER AdditiveExpression; returns 'AdditiveExpression' although none is marked
			Action.RETURN,	// [222] RelationalExpression = ShiftExpression
			RETURN3,	// [223] RelationalExpression = RelationalExpression LESS ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [224] RelationalExpression = RelationalExpression GREATER ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [225] RelationalExpression = RelationalExpression LESS_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [226] RelationalExpression = RelationalExpression GREATER_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [227] RelationalExpression = RelationalExpression INSTANCEOF ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [228] RelationalExpression = RelationalExpression IN ShiftExpression; returns 'ShiftExpression' although none is marked
			Action.RETURN,	// [229] RelationalExpression_NoLBF = ShiftExpression_NoLBF
			RETURN3,	// [230] RelationalExpression_NoLBF = RelationalExpression_NoLBF LESS ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [231] RelationalExpression_NoLBF = RelationalExpression_NoLBF GREATER ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [232] RelationalExpression_NoLBF = RelationalExpression_NoLBF LESS_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [233] RelationalExpression_NoLBF = RelationalExpression_NoLBF GREATER_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [234] RelationalExpression_NoLBF = RelationalExpression_NoLBF INSTANCEOF ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [235] RelationalExpression_NoLBF = RelationalExpression_NoLBF IN ShiftExpression; returns 'ShiftExpression' although none is marked
			Action.RETURN,	// [236] RelationalExpression_NoIn = ShiftExpression
			RETURN3,	// [237] RelationalExpression_NoIn = RelationalExpression_NoIn LESS ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [238] RelationalExpression_NoIn = RelationalExpression_NoIn GREATER ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [239] RelationalExpression_NoIn = RelationalExpression_NoIn LESS_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [240] RelationalExpression_NoIn = RelationalExpression_NoIn GREATER_EQUAL ShiftExpression; returns 'ShiftExpression' although none is marked
			RETURN3,	// [241] RelationalExpression_NoIn = RelationalExpression_NoIn INSTANCEOF ShiftExpression; returns 'ShiftExpression' although none is marked
			Action.RETURN,	// [242] EqualityExpression = RelationalExpression
			RETURN3,	// [243] EqualityExpression = EqualityExpression EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [244] EqualityExpression = EqualityExpression EXCLAMATION_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [245] EqualityExpression = EqualityExpression EQUAL_EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [246] EqualityExpression = EqualityExpression EXCLAMATION_EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			Action.RETURN,	// [247] EqualityExpression_NoLBF = RelationalExpression_NoLBF
			RETURN3,	// [248] EqualityExpression_NoLBF = EqualityExpression_NoLBF EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [249] EqualityExpression_NoLBF = EqualityExpression_NoLBF EXCLAMATION_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [250] EqualityExpression_NoLBF = EqualityExpression_NoLBF EQUAL_EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			RETURN3,	// [251] EqualityExpression_NoLBF = EqualityExpression_NoLBF EXCLAMATION_EQUAL_EQUAL RelationalExpression; returns 'RelationalExpression' although none is marked
			Action.RETURN,	// [252] EqualityExpression_NoIn = RelationalExpression_NoIn
			RETURN3,	// [253] EqualityExpression_NoIn = EqualityExpression_NoIn EQUAL_EQUAL RelationalExpression_NoIn; returns 'RelationalExpression_NoIn' although none is marked
			RETURN3,	// [254] EqualityExpression_NoIn = EqualityExpression_NoIn EXCLAMATION_EQUAL RelationalExpression_NoIn; returns 'RelationalExpression_NoIn' although none is marked
			RETURN3,	// [255] EqualityExpression_NoIn = EqualityExpression_NoIn EQUAL_EQUAL_EQUAL RelationalExpression_NoIn; returns 'RelationalExpression_NoIn' although none is marked
			RETURN3,	// [256] EqualityExpression_NoIn = EqualityExpression_NoIn EXCLAMATION_EQUAL_EQUAL RelationalExpression_NoIn; returns 'RelationalExpression_NoIn' although none is marked
			new Action() {	// [257] BitwiseAndExpression = BitwiseAndExpression AMPERSAND EqualityExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [258] BitwiseAndExpression = EqualityExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [259] BitwiseAndExpression_NoLBF = BitwiseAndExpression_NoLBF AMPERSAND EqualityExpression; returns 'EqualityExpression' although none is marked
			Action.RETURN,	// [260] BitwiseAndExpression_NoLBF = EqualityExpression_NoLBF
			new Action() {	// [261] BitwiseAndExpression_NoIn = BitwiseAndExpression_NoIn AMPERSAND EqualityExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [262] BitwiseAndExpression_NoIn = EqualityExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [263] BitwiseXorExpression = BitwiseXorExpression CARET BitwiseAndExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [264] BitwiseXorExpression = BitwiseAndExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [265] BitwiseXorExpression_NoLBF = BitwiseXorExpression_NoLBF CARET BitwiseAndExpression; returns 'BitwiseAndExpression' although none is marked
			Action.RETURN,	// [266] BitwiseXorExpression_NoLBF = BitwiseAndExpression_NoLBF
			new Action() {	// [267] BitwiseXorExpression_NoIn = BitwiseXorExpression_NoIn CARET BitwiseAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [268] BitwiseXorExpression_NoIn = BitwiseAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [269] BitwiseOrExpression = BitwiseOrExpression PIPE BitwiseXorExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [270] BitwiseOrExpression = BitwiseXorExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [271] BitwiseOrExpression_NoLBF = BitwiseOrExpression_NoLBF PIPE BitwiseXorExpression; returns 'BitwiseXorExpression' although none is marked
			Action.RETURN,	// [272] BitwiseOrExpression_NoLBF = BitwiseXorExpression_NoLBF
			new Action() {	// [273] BitwiseOrExpression_NoIn = BitwiseOrExpression_NoIn PIPE BitwiseXorExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [274] BitwiseOrExpression_NoIn = BitwiseXorExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [275] LogicalAndExpression = LogicalAndExpression AMPERSAND_AMPERSAND BitwiseOrExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [276] LogicalAndExpression = BitwiseOrExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [277] LogicalAndExpression_NoLBF = LogicalAndExpression_NoLBF AMPERSAND_AMPERSAND BitwiseOrExpression; returns 'BitwiseOrExpression' although none is marked
			Action.RETURN,	// [278] LogicalAndExpression_NoLBF = BitwiseOrExpression_NoLBF
			new Action() {	// [279] LogicalAndExpression_NoIn = LogicalAndExpression_NoIn AMPERSAND_AMPERSAND BitwiseOrExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [280] LogicalAndExpression_NoIn = BitwiseOrExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [281] LogicalOrExpression = LogicalOrExpression PIPE_PIPE LogicalAndExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [282] LogicalOrExpression = LogicalAndExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [283] LogicalOrExpression_NoLBF = LogicalOrExpression_NoLBF PIPE_PIPE LogicalAndExpression; returns 'LogicalAndExpression' although none is marked
			Action.RETURN,	// [284] LogicalOrExpression_NoLBF = LogicalAndExpression_NoLBF
			new Action() {	// [285] LogicalOrExpression_NoIn = LogicalOrExpression_NoIn PIPE_PIPE LogicalAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [286] LogicalOrExpression_NoIn = LogicalAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [287] ConditionalExpression = LogicalOrExpression
			RETURN5,	// [288] ConditionalExpression = LogicalOrExpression QUESTION AssignmentExpression COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [289] ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF
			RETURN5,	// [290] ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF QUESTION AssignmentExpression COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [291] ConditionalExpression_NoIn = LogicalOrExpression_NoIn
			RETURN5,	// [292] ConditionalExpression_NoIn = LogicalOrExpression_NoIn QUESTION AssignmentExpression_NoIn COLON AssignmentExpression_NoIn; returns 'AssignmentExpression_NoIn' although none is marked
			Action.RETURN,	// [293] AssignmentExpression = ConditionalExpression
			RETURN3,	// [294] AssignmentExpression = LeftHandSideExpression AssignmentOperator AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [295] AssignmentExpression_NoLBF = ConditionalExpression_NoLBF
			RETURN3,	// [296] AssignmentExpression_NoLBF = LeftHandSideExpression_NoLBF AssignmentOperator AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [297] AssignmentExpression_NoIn = ConditionalExpression_NoIn
			RETURN3,	// [298] AssignmentExpression_NoIn = LeftHandSideExpression AssignmentOperator AssignmentExpression_NoIn; returns 'AssignmentExpression_NoIn' although none is marked
			Action.RETURN,	// [299] AssignmentOperator = EQUAL
			Action.RETURN,	// [300] AssignmentOperator = STAR_EQUAL
			Action.RETURN,	// [301] AssignmentOperator = FORWARD_SLASH_EQUAL
			Action.RETURN,	// [302] AssignmentOperator = PERCENT_EQUAL
			Action.RETURN,	// [303] AssignmentOperator = PLUS_EQUAL
			Action.RETURN,	// [304] AssignmentOperator = MINUS_EQUAL
			Action.RETURN,	// [305] AssignmentOperator = LESS_LESS_EQUAL
			Action.RETURN,	// [306] AssignmentOperator = GREATER_GREATER_EQUAL
			Action.RETURN,	// [307] AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			Action.RETURN,	// [308] AssignmentOperator = AMPERSAND_EQUAL
			Action.RETURN,	// [309] AssignmentOperator = CARET_EQUAL
			Action.RETURN,	// [310] AssignmentOperator = PIPE_EQUAL
			new Action() {	// [311] Expression = Expression COMMA AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [312] Expression = AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [313] Expression_NoLBF = Expression_NoLBF COMMA AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [314] Expression_NoLBF = AssignmentExpression_NoLBF
			new Action() {	// [315] Expression_NoIn = Expression_NoIn COMMA AssignmentExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [316] Expression_NoIn = AssignmentExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [317] Literal = NULL.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol n = _symbols[offset + 1];
					return new JSPrimitiveNode(JSTokens.NULL, n.getStart(), n.getEnd());
				}
			},
			new Action() {	// [318] Literal = TRUE.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					return new JSPrimitiveNode(JSTokens.TRUE, t.getStart(), t.getEnd());
				}
			},
			new Action() {	// [319] Literal = FALSE.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol f = _symbols[offset + 1];
					return new JSPrimitiveNode(JSTokens.FALSE, f.getStart(), f.getEnd());
				}
			},
			new Action() {	// [320] Literal = NUMBER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					return new JSPrimitiveNode(n, _symbol_n.getStart(), _symbol_n.getEnd());
				}
			},
			new Action() {	// [321] Literal = STRING.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					return new JSPrimitiveNode(s, _symbol_s.getStart(), _symbol_s.getEnd());
				}
			},
			new Action() {	// [322] Literal = REGEX.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					return new JSPrimitiveNode(r, _symbol_r.getStart(), _symbol_r.getEnd());
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
	
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		// try inserting ";" to see if it fixes the error
		Simulator sim = new Simulator();
		in.alloc(2);
		Symbol term = new Symbol(JSTokens.SEMICOLON, JSTokens.getTokenName(JSTokens.SEMICOLON));
		in.insert(term, token);
		in.rewind();
		if (sim.parse(in))
		{
			in.rewind();
			report.missingTokenInserted(term);
			return;
		}
		super.recoverFromError(token, in);
	}
}
