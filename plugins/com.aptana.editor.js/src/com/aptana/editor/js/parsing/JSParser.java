package com.aptana.editor.js.parsing;

import beaver.*;
import com.aptana.editor.js.parsing.ast.*;
import java.util.ArrayList;
import com.aptana.parsing.ast.ParseRootNode;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
public class JSParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAREN = 1;
		static public final short IDENTIFIER = 2;
		static public final short LCURLY = 3;
		static public final short LBRACKET = 4;
		static public final short PLUS_PLUS = 5;
		static public final short MINUS_MINUS = 6;
		static public final short STRING = 7;
		static public final short NUMBER = 8;
		static public final short MINUS = 9;
		static public final short PLUS = 10;
		static public final short THIS = 11;
		static public final short NEW = 12;
		static public final short NULL = 13;
		static public final short TRUE = 14;
		static public final short FALSE = 15;
		static public final short REGEX = 16;
		static public final short DELETE = 17;
		static public final short EXCLAMATION = 18;
		static public final short TILDE = 19;
		static public final short TYPEOF = 20;
		static public final short VOID = 21;
		static public final short FUNCTION = 22;
		static public final short SEMICOLON = 23;
		static public final short COMMA = 24;
		static public final short VAR = 25;
		static public final short WHILE = 26;
		static public final short FOR = 27;
		static public final short DO = 28;
		static public final short IF = 29;
		static public final short CONTINUE = 30;
		static public final short BREAK = 31;
		static public final short WITH = 32;
		static public final short SWITCH = 33;
		static public final short RETURN = 34;
		static public final short THROW = 35;
		static public final short TRY = 36;
		static public final short RPAREN = 37;
		static public final short ELSE = 38;
		static public final short RCURLY = 39;
		static public final short COLON = 40;
		static public final short RBRACKET = 41;
		static public final short IN = 42;
		static public final short EQUAL = 43;
		static public final short CASE = 44;
		static public final short DOT = 45;
		static public final short LESS_LESS = 46;
		static public final short GREATER_GREATER = 47;
		static public final short GREATER_GREATER_GREATER = 48;
		static public final short LESS = 49;
		static public final short GREATER = 50;
		static public final short LESS_EQUAL = 51;
		static public final short GREATER_EQUAL = 52;
		static public final short INSTANCEOF = 53;
		static public final short EQUAL_EQUAL = 54;
		static public final short EXCLAMATION_EQUAL = 55;
		static public final short EQUAL_EQUAL_EQUAL = 56;
		static public final short EXCLAMATION_EQUAL_EQUAL = 57;
		static public final short AMPERSAND = 58;
		static public final short CARET = 59;
		static public final short PIPE = 60;
		static public final short AMPERSAND_AMPERSAND = 61;
		static public final short STAR_EQUAL = 62;
		static public final short FORWARD_SLASH_EQUAL = 63;
		static public final short PERCENT_EQUAL = 64;
		static public final short PLUS_EQUAL = 65;
		static public final short MINUS_EQUAL = 66;
		static public final short LESS_LESS_EQUAL = 67;
		static public final short GREATER_GREATER_EQUAL = 68;
		static public final short GREATER_GREATER_GREATER_EQUAL = 69;
		static public final short AMPERSAND_EQUAL = 70;
		static public final short CARET_EQUAL = 71;
		static public final short PIPE_EQUAL = 72;
		static public final short STAR = 73;
		static public final short FORWARD_SLASH = 74;
		static public final short PERCENT = 75;
		static public final short QUESTION = 76;
		static public final short PIPE_PIPE = 77;
		static public final short DEFAULT = 78;
		static public final short FINALLY = 79;
		static public final short CATCH = 80;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGTy5DNpdxUN2qb8Jou522H0212AOASeYYAYI1CGL41w4G51cbqHH045fFVUUxStr9#" +
		"DegY0lQ60OXTHRlxVtNt9xONBvVPsB$7pzowVkNbltfllpBp#ifSBKTNsuWOQJ7U8ldIhog" +
		"aX3Q1hgHjrfPkfcPXC2#aAQa1pQPPOH5Fe2NgIfj8qyPPuKzmckecRnKsYewWdQejcuYBHN" +
		"hGHruccOX$zZzuKxudtnI5wb$Q9ZyHXSKHyB2uKVKHlKOkEK3dwJ1mG1yK7uiC2#sAnM2AM" +
		"YcLYkLWZdXIFYqdIevxmg8tqQ3CzHJDefcNxKUABelRDnKzVMB8V8xug8Vud2kEFfW6YfUw" +
		"HQ4NpQ3ujWFqVBDbF5QU2YFzkkeVkfVkW$HRzQib#YlYzXFXN8lx9XHQJADdJ#kH2$qTOib" +
		"z5dB4GVmxibxDalveuMqBygxtYpwGAXlXpON#u9Vjv2bc8Fn$sHrcoNrU9A27#pLxnRwSiG" +
		"$prON#i9VkPIhb0ugSBlEBNrXwQGxDX$tvBzgzKOlt4Fwq4N#h0$aFMnh#IS4xyG#XskfCU" +
		"eIRKY1wcX#XIQao3w0QwdnwW1saSNKoNK5EwZ2wdxh0$tfBzBKgAHViJBTblhwHPjB$Talr" +
		"sIYMBzdTPif#ZL34x$cawFKvZQI3TGjcm$uorzK#fPZ7#votPxw7Ki6Z$5Mlxlv9lqVuRbk" +
		"pVffntZlq8dpl0gruhO0Uwa2wYvXHFpkBjqrxLFhr5RzCxgdtQJmVe8BrliBy6I3rn2cn5Q" +
		"saTqbjf9BKgiWFy3pk0TjgXtdINqi3WvsHv2hoR51fks1TKrBRk0#8I5PN$fBQM$TJiy1#Y" +
		"iRRg3v2dhq9FH8Bqy5KnMA#hD92xH3zAfDVeTM9gGRaKQzKJ$xtalK#9Ih0vYXnssHGkuBM" +
		"WpZI9HjFwmbvwYchH294augaJvT7LTBr8KssA$fPi3XJveexfDQagVMZPSeweZfEDISkYjS" +
		"YqRBc1gA#EBsOQ8fnqgEWQ8AxniGP4qdlYTagWx#b7#fAEqczqMf28edz41P5b3eVg5ei3h" +
		"wYyIRJwnQ69kp2Aue9Pxp2I3zioUypPz7F72vdDhyh0ff#xPCXi#ha$XigclpjZo6pwkIU6" +
		"h6tBOgwKWKr$T#2GsVHpxmsPJJzttP3Pz7E$3PbDFtVQaDdqSuyDcKq$TzUGsVHpNmsPJJz" +
		"tr93Pz7Cl3PbDFtVHaDdqS$yCcKq$TywGsVp6qltDrCcLXzbmdcu1dA75uV0GaK4Vc43RWF" +
		"FqjcBFq$U8n#WZeFqT8DfESPG#5c#B4#8dyRNuH4Fx8uWOFuTNNzlGLjy0vpiRS8u3vvGDE" +
		"7y2vs$hE4BWRXPf0quqS69jm8a3Zik6zZa4dCes#9C3d6oR$AbgWp#vmAbXapzvDlXJ4#Em" +
		"YWquvyEVYst0QGASosne7xNVMzZWpzN0kTO6dElHpjLim6aBd5mRsYSFSNMmmPzEy2VV1fn" +
		"R$FvkA72Sxlv#AnJu$YLwYgDYa9$zAr0S5t2cMzy7nGpqromRufe7V#RO4DS2xE$vrd60SH" +
		"HOrlsnAwvPm5bb0ywC4lezK9oDmDbe0yu6u6oo0UT5SPI$jA7VKu7pXGt#V0gSpwtZy6V0#" +
		"TG6d4#0u#$S6oZEKU0SiG7dC70#iW7dG#1yO0FE8U2yNooEhoSX6JwV2tUXbhIQAb6wIPtM" +
		"GUlqfKcuSItHdazTHN$G6QgbfLjG7vf0myItz2aT4zLeCIqIoNHIE4HvKKMaqU$qbnY7MjU" +
		"PjBgfbA9RgUg8LCeKKyGACHKU3mtWyoaTRVEi0BSUBHC3q4wJQ99yxZTJt25Ig9Re8huKQU" +
		"9ESOm#AQtU5aF55h5UxA4MQ8zlJVqUuIVUAzRIYLBpz0MjvzwbPB5EZ33rPFyNSLn95yDAp" +
		"TFzzBgYK0ibMZn6RXEV0Ub2bPKaz8HIMfugUKgcMA$amDSC4MEgzt$MUgFKLYNUBaxoDl4p" +
		"RnL$YegcF3tB2yG$uj9IytGAR#7Dl8atyWPnfPdU5#VnUbudHfVQEDt8QtaDh#PLl48yR6f" +
		"6tQlKv9NYWLBRammlCS6KfrirdTrbukaEKvx#gkayMoQUlcJ6KoL6qtcjJ3pzp1U2KiVhip" +
		"g9r05L#uihiAUfEjy5DJi6Q0PxYO7QsOUmBWyHL#7zd4zKYJ6YaMWk7gHNlJpzGNj$HuagY" +
		"tPIXAaUhQ3vwdkl2dMFdZQrcklHESkaJHE3y3IkJ3nD3SBJx3BnD2i8JwkNYQUrWl2qdach" +
		"QK5uMZ48dMk2qBaf29qnGUXC349dHH0w6uFGsH64pguWTDumhoFg1g7JC0YT2pGTStDXbVz" +
		"piBYLnfj4VCmVekY16e$QvEDvce$gQwbDFfvVYBZS5A9FDD5BGxlH1gH#6j8lff0wQ76q8X" +
		"ylCT8KKWilvRO6d4V5VHQGZ1xj58$OXFISs6OJqilYQPkGNXU$sOJqkUAm2UbxfRnDI3ygo" +
		"JOX$QMO#mr2yKYiLBK#xtojjE9oKxZXkk6wuRhXkl$5ke6jgRxlZEVK4#q2U2OK25ADG6g9" +
		"6ttiAUhlbsRRuaNDakk8piNiR8l5N1jyg5qYHbVjhn$FVK4gvfUelL0#cTHsQB6NTXVeKWi" +
		"bKebNN4fbfQv1YfUIItleQNg6dgNdw7bwWLwab#XbUgKOwMuDlQYF6g9IMwaly#OG0tdvrY" +
		"sO5#fBdHVgopWlFENTVPPxNjsf7RN7wVt6GjwHEb5dtFAxQEry2zg#6shreDlGrWrnPxa0h" +
		"J08#6gF3A6XD0oMXjC8kej6qYWQZRl#sCBl5j3jFGGVni6RyJG1jx69k0yff7u3WVxNfGLs" +
		"rRyodIx$mdCMpQOviaHuULIFwkCcPjN#PX$sIpD#XudujtXvT2tkMDU5fFrBZlyYRRsz5Df" +
		"MxQyEAFxQXHRJASFG#lcMxJUr57yJo$ORcun$4IqsnD$8iltvbkAVQzd#KfFnNq#j3V4liM" +
		"n$KL3nwsjFDCLOjh#mXFXByYKKurzWNZieWfmKIUKeIekpFCLI7CLJ0YLgtnEKGgdaehIGn" +
		"FzVikzh$IrD#qs26lyzgHVrfZxKDoJhNsd6xsl$BqtxllR$qhI$nOVzZW6C0A5v5s73#1TQ" +
		"l15Qf8BgOd#FyB43wAUTtPH7omtUrPOhyHhQX1BFlg1eI7iagWDfgtxgTbGajJSMI7yydgo" +
		"KajMqJjPTBhb2MxLJYqgDuATLJypqacfp8pono#O2uAa$yt2Jt6ZefMMq0t7dKIxE4xNmKy" +
		"S6cpTePntpQz8govRRK5kSRCh2idgwKSSNcLe3qc5P$UuwzRbl5bMcAfHDELILgb5rapXBY" +
		"yLHzV9CeYqf5aqTbtbbijw5ROPjXcs6ROPjXcs6ROPjXct#DsoQExdMjE4ydU4NfoP#p9od" +
		"Qm9DAU4yRGvDs11Z3U1Ki05702VT9XmxuagtqHyxnfAAizC670Tm5jY4CyW6d3R0MVylyaV" +
		"udMNc$Ccr0MSGS9hQWAFEzuKsu2Ws#TF4Hd$im57zQMm3JcFWDB81PxwDE7Djm9dhztT3WU" +
		"CizVjReS1nbjYqhYwmSJpRCNxiwlTvDlRxl7zHN8rjwlScDlMxOjD#iG8u#JRWr0PE3PlYi" +
		"WD7s8HJ8uppBy0nyrou7$Md0JImr7JKPr8PykTnnAlGCfdBfGsW2g1Sd3LhqNRjEPNwiutg" +
		"o9E#glDlZYvFUnQcFXsg4v2dkqBWsGRjwTyy$1GyzykZbMZbPHWnTT2QeXJRCA$mYQhQ7kR" +
		"kzkhuBZrFLsWzftgwrhIdwQNgQK6B1ZCRIdS6hIZqqtoRghrHUfxMW7S5P7wSrYnLJpq$Pg" +
		"q6enEyfugNf#RQj7PfUig6brbFfKxOq$yldfQCa4S2DTLFGjMnuEa2JJUNRb3FFaXbO8zMF" +
		"rDrxYUgShLFwkJIQczFjVUjj2RSe$PvQc8KX3qDU$gVyJIi4zOfLHrJSm6xPaasQjcBY1gs" +
		"8cgpkOmH$KQSMqP8GeiZWdsyJ29bUEdMzSAnW5J4ep1I6AdiaCoijAPcORXkk6wuRhZkVx1" +
		"ke6kgVVK2GmgebeyzHV$zaZrU152dc9rDzS8E7qgkWJxsOL$j#Qa1QCidbPfERSelrCsGJo" +
		"PpZLAvPwlVRTEChg0hgJbTHLTJ2xg6MXOZpTVmY$We4O4kywOGYpjDU5dmhIldXLO3yqBZn" +
		"dbHM8vvuQFSW9z6f3HyGFkwajZ1H95xrNG1uNK9g0rebvwF$5xdvH8DTKuJYSPwMgHBNe$8" +
		"uV3KoNbQvuxcEbSYaNuOzPg2lm9#Ar54S$3xmLNv8d38wJFOQenyDV2xaAy5lWdwJu1$Z$m" +
		"KegXg7ZjHj#hScMoC8n22ZajYp4BwZ4mVaFu#1raZekZou7zxTAhc8zyCCUpso2gbIhn$T1" +
		"vzjOpzUKyT1nli8hu8sRxfBo8$W2Yb1JXYSwufukEeS$sEHfkbj9JbbqYUBtalq8#eiqVFY" +
		"up0swFYKCddUCl5ClzwIhyYFZzcI3lFhPzohRJpikGdVEF6Oep4FWX2kyIkH4o$#gZphivZ" +
		"wYBz3dW$NrY1nU#SAR6M1ASVErNotKNaVm3pAE9kXJJ6T#olH74ElImk3oH0JOZAkr3dEgH" +
		"hoh8Ua64kfhH5#ZefwqcKUZEHgol6tQN83v5jsakMto7plMLUzgbhaunnjfIl1lP4r6k7z7" +
		"GfmpoCa#CoxcsKOpwcj4VwHwdxbyxJ9KPAQybNUc8jVnRnOQx68TuuHlfYw1tKo#AJiPvS2" +
		"FbncU$gqOi7YqTVnpy4MkgHv#pLUORicqYi2HadK0TZ8hCP#5xm6PxwpZuwppmEF$VfwOG4" +
		"QUC3egpVmVz2sGj4bNF0zyiwdJqOLJ4$Autmv1EkG5t4aN2LpFT5lZKuvct2PAGnvqHtq6o" +
		"ans0#OEroraSQxU2i0#g1z0hu$ZJMC2VIpq06VMSdf0yKsD6nAn$ppYS29nvuyTUWdN$MPQ" +
		"drPBiZZlX1UhfSPVZS3VadP1yTH7gRdevzZIYj2yhHl$4Vol93IFyjSVgW3ECXeOgUhuG#I" +
		"93hTkMpXhxuYgXAYjGPXpJMviJBm2y7lmsy8tXly47W65jL7jJ#jm1LcOMDvslm3OXv96Wi" +
		"051FoK0zz4SIzgGaZEKg66z9M5#h7DPj967zJSBQd0hyf3bIzXJAJ#dfj8tm5NC#eP$qUnN" +
		"IZyisGfzL#WLvEUuhOJmdl2SnTX5benyg$GpPdpAsgP1LnFY0BuaLlViW2Nj1iWEOCv7#0l" +
		"mxvA6VZBcRZ3P8nfnDHdyc3m4D0qq7pG31Jl8U4EP2yYUWch3H03OmlX8HKmhMXKICdLJe9" +
		"av0$aQaqO$PwEiiZ9dKBPYtw3FN6iYm5cOzWdhha0TtWQTkHZ$2hwnqoFT11WmNsZXxE6Hh" +
		"8SCwure2MWo$KSVr4UIebmJxhiFGnnp9mhgJXB7hEe8sM82qQW$#ffu4zaqeHxyceLrT7wD" +
		"y8T9l8OrONDZFiyOZVmffn963$Jiv1Ua$qIzOKrmO5ndeWopucOovauRpGGxyICRQbOOnxM" +
		"g6ilt8OozBEmzbY35v6T9edpJ4dutna$CkPAyZtn3f#P31HWxyJyRyJxlUqpyHE1yuMnhxJ" +
		"2MCkJV1v9XsolNM#P11xumdJTCywSpjdhGuNyhUzSXIT#ZS8UUNywpEi#NQaurs4fYBsL$e" +
		"OpsdcdxEKSReQqJA9ks$fr15mpvPKMA9eqNZA8c0MqddoOSDCNndA4VR9NljdMYRVo3$s1i" +
		"dfPvtleBYtwu3xHiXz$A8EVxg#jPFQUb9EmTubpcRIXzaRCxnWUCclo1rBoeYVzM$dlEaTp" +
		"woko4zmKySFQMzje7vLs6Wdx9naYyCD5u$MBk3qtC#AsC#TcvPYhRNOlp8TRLSZkGt6#hiz" +
		"w4dz$noXhqwOZlcKgw#lfVR5vXlgMDzo9xIULIqHnRLt50kpm5ncTBkQHdd2EdRS5dUoQ0Z" +
		"xprExB5HzsAzgkufYrkFiOHpHvpSQ#D#y#rhV3TFMZ$NeqyEUcIkxL9sKkSL8mswxMITotn" +
		"ZPpqZwyr1dJ6#wz0zA7$EMnRPo3kVFSQGndwJWFqi0VjHDlQEb56WqLY$Be0CQte2zfMAk1" +
		"ycuDwOWBDDHUmD2TD0wCUAHxnnAx8nBsrVXBR4dfWkxqS97tlAedusj0lsp#XyJpwwZw4CU" +
		"u8B#s$q8aEvOTrBmreRa#B9nsXdL8pNRHvPYleDe#TxyefSuvqJPFd3iZqcIuvzAX7ZD0Vd" +
		"rqISuNCwWAjxDlRxnA6WgKNQlM0jDzX8TUeyASCZ4x9U6kx4QMZdc0cUifYN336XZMCCTz3" +
		"o5nhAtf4oUGz8ZONic9HvtILrMNg7eh9W23XLLOvsbMSngYzjVcMeqyI7tYXPVuX1XhDD#a" +
		"xrB8xC9eyyexoiUyeZ4$KDQGD61lf767I5GIUZ1mZxi6BGLOowEv0tw2eofbIvncNWp94PW" +
		"$tEeEymw6TMHzwWxp3OpkokymZPFgdlGJP6oWmOIaCzL7RpF$otJ9y1OHxoB$opbly9j8zn" +
		"0kCttQUu7UDUwFxHZHEq6ngCMoIN0yM1S1BZIY3CPiRfYZ7pk2dZdCgjeDUQh#Thk0LVpLT" +
		"nSxwIh#1cV3btv1kvXsO7vq7t9#upt4VBtUx6sKzDyo0UY7VS91WdG#xCn7VmO8xa2JnUg$" +
		"aN5RxuT$wDJtCiFyBZ#67MlZMNSHzWtDzuXAnp9oTpEgUnYrFT7xe$S1zol#z#pusRYxfuy" +
		"FqybaTn5bVXoboTgt5Lpk5ihirrkGxdSmC#dnlonTo8B#LB6ATDlW#4bPhluT4yXaVotGPl" +
		"XdCdxirOhxYRBd7$vlxU$PtxcFjRzpVkhzrVkRzqV#7#tFsP#rF62iCurRgFye$y0v$a4to" +
		"Sl#Vl#1X$oz$mrunR4ACN#I0VS1yXmujVzygzMfXwnI1z6RGSXBCkBmNXVCwBGOiAQopaSN" +
		"X$eZ2FqnlF0yq5uJR4Ctc69f$EqpG#MNkVn8$X$L5#l51leli7RiCt89AJRemYj#mTzo$SW" +
		"TlpBLeTdCQvg$iqfCozD4b$K3##LUrnxiiztMwad3o08y3BCsO19t4YtYimRakSnxZJS3t6" +
		"YieNCExst9YRyBNWBNa$uwx6K$b9l6ENujaQ$alIknUrznSAlNrUUtzEvfxLtd5FTXzsds3" +
		"iFUxZRim1DsuNxhCemQs7eq498DmYEPThS2R7SnGhxdzad3#v$v1ex$3$yFw6p3sjlU#HEU" +
		"sRetaNlotpErHhMcgd#oD#pJ3pJcafRJneASDuAExb6GF5rXXNKetWNWNn8DMkC7LM#ptj7" +
		"XAqYHIGeEMIEb84TI47ID1cb6r6UhT6WhOWlmNfsv6#NUEAJ0TEapHIlwbHaUd0QH2ftv7i" +
		"e5NWgv3VYlHMyBNWQy5NQ#IW5U0hmE#cSY0dJGQ$HoCdA5AcLOeoS9MY3LobcCBoAU1Je3y" +
		"5#dfQfIW3LodQm5MAAIo$5pxV2v$k0xyF$7xm#y4V0EOJe8T0Eo7R2PbE4PASj1BobOXf0U" +
		"GB85k7$3ga7mGz2NeODAwG8cWRTDQZpatGKQdTEUIW3YZle76L8a1EsewoxP1lXsmxP1kGt" +
		"W1PP$3EaEtGo4aR8IkWJeKK0N9eD0Bv4SYFqD8EwefyLs2C1nzFwl$VBQ08a8FkGbgd2923" +
		"5YAz47oNHe9kbZHSKZUD59e0FW5y4RXAjsYaqAFWZuAhtufI4dNNo463mGU3Bm4le1uQEUW" +
		"Ey3l0buAhT9j6wl$mKVyFf8FcWXTGJuqSD1HyAFXKyAdWyy2BqZ99lJHoq33mOU3JmAU1pm" +
		"StKc$8UeEF11y9FXryEdWVy3xWey17WJy5$XHuNt3rKoIZmKU3pm2V0TuFl1$u6F0nu3F1P" +
		"u8F01y0VYVudU2pm6U13zJ8IHF19uBF0Py3tX#yF#getmYZVllgRF3Pu8l1pT3Zq54$MpiM" +
		"V2pu6l0ruEsBeKV#3zI3kaa=");

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN10 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 10];
		}
	};

	private final Action[] actions;

	public JSParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] Program = SourceElements.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final beaver.Symbol[] p = _list_p == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_p.toArray(new beaver.Symbol[_list_p.size()]);
					return new ParseRootNode(p, _symbol_p.getStart(), _symbol_p.getEnd());
				}
			},
			new Action() {	// [1] SourceElements = SourceElements SourceElement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [2] SourceElements = SourceElement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [3] SourceElement = FunctionDeclaration
			Action.RETURN,	// [4] SourceElement = Statement
			RETURN4,	// [5] FunctionDeclaration = FUNCTION IDENTIFIER FunctionParameters FunctionBody; returns 'FunctionBody' although none is marked
			RETURN3,	// [6] FunctionExpression = FUNCTION FunctionParameters FunctionBody; returns 'FunctionBody' although none is marked
			Action.RETURN,	// [7] FunctionExpression = FunctionDeclaration
			RETURN2,	// [8] FunctionParameters = LPAREN RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [9] FunctionParameters = LPAREN FormalParameterList RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [10] FormalParameterList = FormalParameterList COMMA IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [11] FormalParameterList = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN2,	// [12] FunctionBody = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [13] FunctionBody = LCURLY SourceElements RCURLY; returns 'RCURLY' although none is marked
			Action.RETURN,	// [14] Statement = Block
			RETURN3,	// [15] Statement = VAR VariableDeclarationList SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [16] Statement = Expression_NoLBF.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					((JSNode) e).setSemicolonIncluded(true); return e;
				}
			},
			Action.RETURN,	// [17] Statement = IfStatement
			Action.RETURN,	// [18] Statement = IterationStatement
			Action.RETURN,	// [19] Statement = ContinueStatement
			Action.RETURN,	// [20] Statement = BreakStatement
			Action.RETURN,	// [21] Statement = ReturnStatement
			Action.RETURN,	// [22] Statement = WithStatement
			Action.RETURN,	// [23] Statement = LabelledStatement
			Action.RETURN,	// [24] Statement = SwitchStatement
			Action.RETURN,	// [25] Statement = ThrowStatement
			Action.RETURN,	// [26] Statement = TryStatement
			new Action() {	// [27] Statement = SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					return new JSNode(JSNodeTypes.EMPTY, s.getStart(), s.getEnd(), true);
				}
			},
			new Action() {	// [28] Statement = error.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return new JSNode(JSNodeTypes.ERROR, e.getStart(), e.getEnd());
				}
			},
			Action.RETURN,	// [29] Statement_NoIf = Block
			RETURN3,	// [30] Statement_NoIf = VAR VariableDeclarationList SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [31] Statement_NoIf = Expression_NoLBF.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					((JSNode) e).setSemicolonIncluded(true); return e;
				}
			},
			Action.RETURN,	// [32] Statement_NoIf = IfStatement_NoIf
			Action.RETURN,	// [33] Statement_NoIf = IterationStatement_NoIf
			Action.RETURN,	// [34] Statement_NoIf = ContinueStatement
			Action.RETURN,	// [35] Statement_NoIf = BreakStatement
			Action.RETURN,	// [36] Statement_NoIf = ReturnStatement
			Action.RETURN,	// [37] Statement_NoIf = WithStatement_NoIf
			Action.RETURN,	// [38] Statement_NoIf = LabelledStatement_NoIf
			Action.RETURN,	// [39] Statement_NoIf = SwitchStatement
			Action.RETURN,	// [40] Statement_NoIf = ThrowStatement
			Action.RETURN,	// [41] Statement_NoIf = TryStatement
			new Action() {	// [42] Statement_NoIf = SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					return new JSNode(JSNodeTypes.EMPTY, s.getStart(), s.getEnd());
				}
			},
			new Action() {	// [43] Statement_NoIf = error.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return new JSNode(JSNodeTypes.ERROR, e.getStart(), e.getEnd());
				}
			},
			new Action() {	// [44] Block = LCURLY.l RCURLY.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					return new JSNaryNode(JSNodeTypes.STATEMENT, l.getStart(), r.getEnd());
				}
			},
			RETURN3,	// [45] Block = LCURLY StatementList RCURLY; returns 'RCURLY' although none is marked
			new Action() {	// [46] StatementList = StatementList Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [47] StatementList = Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [48] VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [49] VariableDeclarationList = VariableDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [50] VariableDeclarationList_NoIn = VariableDeclarationList_NoIn COMMA VariableDeclaration_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [51] VariableDeclarationList_NoIn = VariableDeclaration_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [52] VariableDeclaration = IDENTIFIER
			RETURN3,	// [53] VariableDeclaration = IDENTIFIER EQUAL AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [54] VariableDeclaration_NoIn = IDENTIFIER
			RETURN3,	// [55] VariableDeclaration_NoIn = IDENTIFIER EQUAL AssignmentExpression_NoIn; returns 'AssignmentExpression_NoIn' although none is marked
			RETURN7,	// [56] IfStatement = IF LPAREN Expression RPAREN Statement_NoIf ELSE Statement; returns 'Statement' although none is marked
			RETURN5,	// [57] IfStatement = IF LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [58] IfStatement_NoIf = IF LPAREN Expression RPAREN Statement_NoIf ELSE Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [59] IterationStatement = DO Statement WHILE LPAREN Expression RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [60] IterationStatement = WHILE LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN6,	// [61] IterationStatement = FOR LPAREN SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [62] IterationStatement = FOR LPAREN SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [63] IterationStatement = FOR LPAREN SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [64] IterationStatement = FOR LPAREN SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [65] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [66] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [67] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [68] IterationStatement = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [69] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [70] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN9,	// [71] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement; returns 'Statement' although none is marked
			RETURN10,	// [72] IterationStatement = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [73] IterationStatement = FOR LPAREN LeftHandSideExpression IN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN8,	// [74] IterationStatement = FOR LPAREN VAR VariableDeclaration_NoIn IN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN7,	// [75] IterationStatement_NoIf = DO Statement WHILE LPAREN Expression RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [76] IterationStatement_NoIf = WHILE LPAREN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN6,	// [77] IterationStatement_NoIf = FOR LPAREN SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [78] IterationStatement_NoIf = FOR LPAREN SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [79] IterationStatement_NoIf = FOR LPAREN SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [80] IterationStatement_NoIf = FOR LPAREN SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [81] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [82] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [83] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [84] IterationStatement_NoIf = FOR LPAREN Expression_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [85] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [86] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN9,	// [87] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN10,	// [88] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclarationList_NoIn SEMICOLON Expression SEMICOLON Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN7,	// [89] IterationStatement_NoIf = FOR LPAREN LeftHandSideExpression IN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN8,	// [90] IterationStatement_NoIf = FOR LPAREN VAR VariableDeclaration_NoIn IN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			new Action() {	// [91] ContinueStatement = CONTINUE.c SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol c = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSNodeTypes.CONTINUE, c.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [92] ContinueStatement = CONTINUE.c IDENTIFIER.i SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol s = _symbols[offset + 3];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSNodeTypes.CONTINUE, i, c.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [93] BreakStatement = BREAK.b SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSNodeTypes.BREAK, b.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			new Action() {	// [94] BreakStatement = BREAK.b IDENTIFIER.i SEMICOLON.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol s = _symbols[offset + 3];
					
			JSLabelStatementNode node = new JSLabelStatementNode(JSNodeTypes.BREAK, i, b.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
				}
			},
			RETURN2,	// [95] ReturnStatement = RETURN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [96] ReturnStatement = RETURN Expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [97] WithStatement = WITH LPAREN Expression RPAREN Statement; returns 'Statement' although none is marked
			RETURN5,	// [98] WithStatement_NoIf = WITH LPAREN Expression RPAREN Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN5,	// [99] SwitchStatement = SWITCH LPAREN Expression RPAREN CaseBlock; returns 'CaseBlock' although none is marked
			RETURN2,	// [100] CaseBlock = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [101] CaseBlock = LCURLY CaseClauses RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [102] CaseBlock = LCURLY DefaultClause RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [103] CaseBlock = LCURLY DefaultClause CaseClauses RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [104] CaseBlock = LCURLY CaseClauses DefaultClause RCURLY; returns 'RCURLY' although none is marked
			RETURN5,	// [105] CaseBlock = LCURLY CaseClauses DefaultClause CaseClauses RCURLY; returns 'RCURLY' although none is marked
			new Action() {	// [106] CaseClauses = CaseClauses CaseClause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [107] CaseClauses = CaseClause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [108] CaseClause = CASE Expression COLON; returns 'COLON' although none is marked
			RETURN4,	// [109] CaseClause = CASE Expression COLON StatementList; returns 'StatementList' although none is marked
			RETURN2,	// [110] DefaultClause = DEFAULT COLON; returns 'COLON' although none is marked
			RETURN3,	// [111] DefaultClause = DEFAULT COLON StatementList; returns 'StatementList' although none is marked
			RETURN3,	// [112] LabelledStatement = IDENTIFIER COLON Statement; returns 'Statement' although none is marked
			RETURN3,	// [113] LabelledStatement_NoIf = IDENTIFIER COLON Statement_NoIf; returns 'Statement_NoIf' although none is marked
			RETURN3,	// [114] ThrowStatement = THROW Expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [115] TryStatement = TRY Block Catch; returns 'Catch' although none is marked
			RETURN3,	// [116] TryStatement = TRY Block Finally; returns 'Finally' although none is marked
			RETURN4,	// [117] TryStatement = TRY Block Catch Finally; returns 'Finally' although none is marked
			RETURN5,	// [118] Catch = CATCH LPAREN IDENTIFIER RPAREN Block; returns 'Block' although none is marked
			RETURN2,	// [119] Finally = FINALLY Block; returns 'Block' although none is marked
			Action.RETURN,	// [120] PrimaryExpression = PrimaryExpression_NoLBF
			Action.RETURN,	// [121] PrimaryExpression = ObjectLiteral
			new Action() {	// [122] PrimaryExpression_NoLBF = THIS.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					return new JSPrimitiveNode(JSNodeTypes.THIS, t.value.toString(), t.getStart(), t.getEnd());
				}
			},
			new Action() {	// [123] PrimaryExpression_NoLBF = IDENTIFIER.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					return new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, t, _symbol_t.getStart(), _symbol_t.getEnd());
				}
			},
			Action.RETURN,	// [124] PrimaryExpression_NoLBF = Literal
			Action.RETURN,	// [125] PrimaryExpression_NoLBF = ArrayLiteral
			RETURN3,	// [126] PrimaryExpression_NoLBF = LPAREN Expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [127] ArrayLiteral = LBRACKET RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [128] ArrayLiteral = LBRACKET Elision RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [129] ArrayLiteral = LBRACKET ElementList RBRACKET; returns 'RBRACKET' although none is marked
			RETURN4,	// [130] ArrayLiteral = LBRACKET ElementList COMMA RBRACKET; returns 'RBRACKET' although none is marked
			RETURN5,	// [131] ArrayLiteral = LBRACKET ElementList COMMA Elision RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [132] ElementList = AssignmentExpression
			RETURN2,	// [133] ElementList = Elision AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN3,	// [134] ElementList = ElementList COMMA AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN4,	// [135] ElementList = ElementList COMMA Elision AssignmentExpression; returns 'AssignmentExpression' although none is marked
			new Action() {	// [136] Elision = Elision COMMA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [137] Elision = COMMA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [138] ObjectLiteral = LCURLY RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [139] ObjectLiteral = LCURLY PropertyNameAndValueList RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [140] PropertyNameAndValueList = PropertyName COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			RETURN5,	// [141] PropertyNameAndValueList = PropertyNameAndValueList COMMA PropertyName COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [142] PropertyName = IDENTIFIER
			Action.RETURN,	// [143] PropertyName = STRING
			Action.RETURN,	// [144] PropertyName = NUMBER
			Action.RETURN,	// [145] MemberExpression = PrimaryExpression
			Action.RETURN,	// [146] MemberExpression = FunctionExpression
			RETURN4,	// [147] MemberExpression = MemberExpression LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [148] MemberExpression = MemberExpression DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [149] MemberExpression = NEW MemberExpression Arguments; returns 'Arguments' although none is marked
			Action.RETURN,	// [150] MemberExpression_NoLBF = PrimaryExpression_NoLBF
			RETURN4,	// [151] MemberExpression_NoLBF = MemberExpression_NoLBF LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [152] MemberExpression_NoLBF = MemberExpression_NoLBF DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [153] MemberExpression_NoLBF = NEW MemberExpression Arguments; returns 'Arguments' although none is marked
			Action.RETURN,	// [154] NewExpression = MemberExpression
			RETURN2,	// [155] NewExpression = NEW NewExpression; returns 'NewExpression' although none is marked
			Action.RETURN,	// [156] NewExpression_NoLBF = MemberExpression_NoLBF
			RETURN2,	// [157] NewExpression_NoLBF = NEW NewExpression; returns 'NewExpression' although none is marked
			RETURN2,	// [158] CallExpression = MemberExpression Arguments; returns 'Arguments' although none is marked
			RETURN2,	// [159] CallExpression = CallExpression Arguments; returns 'Arguments' although none is marked
			RETURN4,	// [160] CallExpression = CallExpression LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [161] CallExpression = CallExpression DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [162] CallExpression_NoLBF = MemberExpression_NoLBF Arguments; returns 'Arguments' although none is marked
			RETURN2,	// [163] CallExpression_NoLBF = CallExpression_NoLBF Arguments; returns 'Arguments' although none is marked
			RETURN4,	// [164] CallExpression_NoLBF = CallExpression_NoLBF LBRACKET Expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN3,	// [165] CallExpression_NoLBF = CallExpression_NoLBF DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [166] Arguments = LPAREN RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [167] Arguments = LPAREN ArgumentList RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [168] ArgumentList = ArgumentList COMMA AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [169] ArgumentList = AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [170] LeftHandSideExpression = NewExpression
			Action.RETURN,	// [171] LeftHandSideExpression = CallExpression
			Action.RETURN,	// [172] LeftHandSideExpression_NoLBF = NewExpression_NoLBF
			Action.RETURN,	// [173] LeftHandSideExpression_NoLBF = CallExpression_NoLBF
			Action.RETURN,	// [174] PostfixExpression = LeftHandSideExpression
			RETURN2,	// [175] PostfixExpression = LeftHandSideExpression PostfixOperator; returns 'PostfixOperator' although none is marked
			Action.RETURN,	// [176] PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF
			RETURN2,	// [177] PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF PostfixOperator; returns 'PostfixOperator' although none is marked
			Action.RETURN,	// [178] PostfixOperator = PLUS_PLUS
			Action.RETURN,	// [179] PostfixOperator = MINUS_MINUS
			Action.RETURN,	// [180] UnaryExpression = PostfixExpression
			RETURN2,	// [181] UnaryExpression = UnaryOperator UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [182] UnaryExpression_NoLBF = PostfixExpression_NoLBF
			RETURN2,	// [183] UnaryExpression_NoLBF = UnaryOperator UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [184] UnaryOperator = DELETE
			Action.RETURN,	// [185] UnaryOperator = EXCLAMATION
			Action.RETURN,	// [186] UnaryOperator = MINUS
			Action.RETURN,	// [187] UnaryOperator = MINUS_MINUS
			Action.RETURN,	// [188] UnaryOperator = PLUS
			Action.RETURN,	// [189] UnaryOperator = PLUS_PLUS
			Action.RETURN,	// [190] UnaryOperator = TILDE
			Action.RETURN,	// [191] UnaryOperator = TYPEOF
			Action.RETURN,	// [192] UnaryOperator = VOID
			new Action() {	// [193] MultiplicativeExpression = UnaryExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return e;
				}
			},
			RETURN3,	// [194] MultiplicativeExpression = MultiplicativeExpression MultiplicativeOperator UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [195] MultiplicativeExpression_NoLBF = UnaryExpression_NoLBF
			RETURN3,	// [196] MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF MultiplicativeOperator UnaryExpression; returns 'UnaryExpression' although none is marked
			Action.RETURN,	// [197] MultiplicativeOperator = STAR
			Action.RETURN,	// [198] MultiplicativeOperator = FORWARD_SLASH
			Action.RETURN,	// [199] MultiplicativeOperator = PERCENT
			new Action() {	// [200] AdditiveExpression = MultiplicativeExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [201] AdditiveExpression = AdditiveExpression.l AdditiveOperator.o MultiplicativeExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [202] AdditiveExpression_NoLBF = MultiplicativeExpression_NoLBF
			new Action() {	// [203] AdditiveExpression_NoLBF = AdditiveExpression_NoLBF.l AdditiveOperator.o MultiplicativeExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [204] AdditiveOperator = PLUS
			Action.RETURN,	// [205] AdditiveOperator = MINUS
			new Action() {	// [206] ShiftExpression = AdditiveExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [207] ShiftExpression = ShiftExpression.l ShiftOperator.o AdditiveExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [208] ShiftExpression_NoLBF = AdditiveExpression_NoLBF
			new Action() {	// [209] ShiftExpression_NoLBF = ShiftExpression_NoLBF.l ShiftOperator.o AdditiveExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [210] ShiftOperator = LESS_LESS
			Action.RETURN,	// [211] ShiftOperator = GREATER_GREATER
			Action.RETURN,	// [212] ShiftOperator = GREATER_GREATER_GREATER
			new Action() {	// [213] RelationalExpression = ShiftExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [214] RelationalExpression = RelationalExpression.l RelationalOperator.o ShiftExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [215] RelationalExpression_NoLBF = ShiftExpression_NoLBF
			new Action() {	// [216] RelationalExpression_NoLBF = RelationalExpression_NoLBF.l RelationalOperator.o ShiftExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [217] RelationalExpression_NoIn = ShiftExpression
			new Action() {	// [218] RelationalExpression_NoIn = RelationalExpression_NoIn.l RelationalOperator_NoIn.o ShiftExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [219] RelationalOperator_NoIn = LESS
			Action.RETURN,	// [220] RelationalOperator_NoIn = GREATER
			Action.RETURN,	// [221] RelationalOperator_NoIn = LESS_EQUAL
			Action.RETURN,	// [222] RelationalOperator_NoIn = GREATER_EQUAL
			Action.RETURN,	// [223] RelationalOperator_NoIn = INSTANCEOF
			Action.RETURN,	// [224] RelationalOperator = RelationalOperator_NoIn
			Action.RETURN,	// [225] RelationalOperator = IN
			new Action() {	// [226] EqualityExpression = RelationalExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [227] EqualityExpression = EqualityExpression.l EqualityOperator.o RelationalExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [228] EqualityExpression_NoLBF = RelationalExpression_NoLBF
			new Action() {	// [229] EqualityExpression_NoLBF = EqualityExpression_NoLBF.l EqualityOperator.o RelationalExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [230] EqualityExpression_NoIn = RelationalExpression_NoIn
			new Action() {	// [231] EqualityExpression_NoIn = EqualityExpression_NoIn.l EqualityOperator.o RelationalExpression_NoIn.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSBinaryOperatorNode(l, o, r);
				}
			},
			Action.RETURN,	// [232] EqualityOperator = EQUAL_EQUAL
			Action.RETURN,	// [233] EqualityOperator = EXCLAMATION_EQUAL
			Action.RETURN,	// [234] EqualityOperator = EQUAL_EQUAL_EQUAL
			Action.RETURN,	// [235] EqualityOperator = EXCLAMATION_EQUAL_EQUAL
			RETURN3,	// [236] BitwiseAndExpression = BitwiseAndExpression AMPERSAND EqualityExpression; returns 'EqualityExpression' although none is marked
			new Action() {	// [237] BitwiseAndExpression = EqualityExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					return e;
				}
			},
			RETURN3,	// [238] BitwiseAndExpression_NoLBF = BitwiseAndExpression_NoLBF AMPERSAND EqualityExpression; returns 'EqualityExpression' although none is marked
			Action.RETURN,	// [239] BitwiseAndExpression_NoLBF = EqualityExpression_NoLBF
			new Action() {	// [240] BitwiseAndExpression_NoIn = BitwiseAndExpression_NoIn AMPERSAND EqualityExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [241] BitwiseAndExpression_NoIn = EqualityExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [242] BitwiseXorExpression = BitwiseXorExpression CARET BitwiseAndExpression; returns 'BitwiseAndExpression' although none is marked
			new Action() {	// [243] BitwiseXorExpression = BitwiseAndExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return e;
				}
			},
			RETURN3,	// [244] BitwiseXorExpression_NoLBF = BitwiseXorExpression_NoLBF CARET BitwiseAndExpression; returns 'BitwiseAndExpression' although none is marked
			Action.RETURN,	// [245] BitwiseXorExpression_NoLBF = BitwiseAndExpression_NoLBF
			new Action() {	// [246] BitwiseXorExpression_NoIn = BitwiseXorExpression_NoIn CARET BitwiseAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [247] BitwiseXorExpression_NoIn = BitwiseAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [248] BitwiseOrExpression = BitwiseOrExpression PIPE BitwiseXorExpression; returns 'BitwiseXorExpression' although none is marked
			new Action() {	// [249] BitwiseOrExpression = BitwiseXorExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return e;
				}
			},
			RETURN3,	// [250] BitwiseOrExpression_NoLBF = BitwiseOrExpression_NoLBF PIPE BitwiseXorExpression; returns 'BitwiseXorExpression' although none is marked
			Action.RETURN,	// [251] BitwiseOrExpression_NoLBF = BitwiseXorExpression_NoLBF
			new Action() {	// [252] BitwiseOrExpression_NoIn = BitwiseOrExpression_NoIn PIPE BitwiseXorExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [253] BitwiseOrExpression_NoIn = BitwiseXorExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [254] LogicalAndExpression = LogicalAndExpression AMPERSAND_AMPERSAND BitwiseOrExpression; returns 'BitwiseOrExpression' although none is marked
			new Action() {	// [255] LogicalAndExpression = BitwiseOrExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return e;
				}
			},
			RETURN3,	// [256] LogicalAndExpression_NoLBF = LogicalAndExpression_NoLBF AMPERSAND_AMPERSAND BitwiseOrExpression; returns 'BitwiseOrExpression' although none is marked
			Action.RETURN,	// [257] LogicalAndExpression_NoLBF = BitwiseOrExpression_NoLBF
			new Action() {	// [258] LogicalAndExpression_NoIn = LogicalAndExpression_NoIn AMPERSAND_AMPERSAND BitwiseOrExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [259] LogicalAndExpression_NoIn = BitwiseOrExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [260] LogicalOrExpression = LogicalOrExpression PIPE_PIPE LogicalAndExpression; returns 'LogicalAndExpression' although none is marked
			new Action() {	// [261] LogicalOrExpression = LogicalAndExpression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					return e;
				}
			},
			RETURN3,	// [262] LogicalOrExpression_NoLBF = LogicalOrExpression_NoLBF PIPE_PIPE LogicalAndExpression; returns 'LogicalAndExpression' although none is marked
			Action.RETURN,	// [263] LogicalOrExpression_NoLBF = LogicalAndExpression_NoLBF
			new Action() {	// [264] LogicalOrExpression_NoIn = LogicalOrExpression_NoIn PIPE_PIPE LogicalAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [265] LogicalOrExpression_NoIn = LogicalAndExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [266] ConditionalExpression = LogicalOrExpression
			RETURN5,	// [267] ConditionalExpression = LogicalOrExpression QUESTION AssignmentExpression COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [268] ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF
			RETURN5,	// [269] ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF QUESTION AssignmentExpression COLON AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [270] ConditionalExpression_NoIn = LogicalOrExpression_NoIn
			RETURN5,	// [271] ConditionalExpression_NoIn = LogicalOrExpression_NoIn QUESTION AssignmentExpression_NoIn COLON AssignmentExpression_NoIn; returns 'AssignmentExpression_NoIn' although none is marked
			Action.RETURN,	// [272] AssignmentExpression = ConditionalExpression
			new Action() {	// [273] AssignmentExpression = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSAssignmentNode(l, o, r);
				}
			},
			Action.RETURN,	// [274] AssignmentExpression_NoLBF = ConditionalExpression_NoLBF
			new Action() {	// [275] AssignmentExpression_NoLBF = LeftHandSideExpression_NoLBF.l AssignmentOperator.o AssignmentExpression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSAssignmentNode(l, o, r);
				}
			},
			Action.RETURN,	// [276] AssignmentExpression_NoIn = ConditionalExpression_NoIn
			new Action() {	// [277] AssignmentExpression_NoIn = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression_NoIn.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					return new JSAssignmentNode(l, o, r);
				}
			},
			Action.RETURN,	// [278] AssignmentOperator = EQUAL
			Action.RETURN,	// [279] AssignmentOperator = STAR_EQUAL
			Action.RETURN,	// [280] AssignmentOperator = FORWARD_SLASH_EQUAL
			Action.RETURN,	// [281] AssignmentOperator = PERCENT_EQUAL
			Action.RETURN,	// [282] AssignmentOperator = PLUS_EQUAL
			Action.RETURN,	// [283] AssignmentOperator = MINUS_EQUAL
			Action.RETURN,	// [284] AssignmentOperator = LESS_LESS_EQUAL
			Action.RETURN,	// [285] AssignmentOperator = GREATER_GREATER_EQUAL
			Action.RETURN,	// [286] AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			Action.RETURN,	// [287] AssignmentOperator = AMPERSAND_EQUAL
			Action.RETURN,	// [288] AssignmentOperator = CARET_EQUAL
			Action.RETURN,	// [289] AssignmentOperator = PIPE_EQUAL
			new Action() {	// [290] Expression = Expression COMMA AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [291] Expression = AssignmentExpression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN3,	// [292] Expression_NoLBF = Expression_NoLBF COMMA AssignmentExpression; returns 'AssignmentExpression' although none is marked
			Action.RETURN,	// [293] Expression_NoLBF = AssignmentExpression_NoLBF
			new Action() {	// [294] Expression_NoIn = Expression_NoIn COMMA AssignmentExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [295] Expression_NoIn = AssignmentExpression_NoIn
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [296] Literal = NULL.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol n = _symbols[offset + 1];
					return new JSPrimitiveNode(JSNodeTypes.NULL, n.value.toString(), n.getStart(), n.getEnd());
				}
			},
			new Action() {	// [297] Literal = TRUE.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					return new JSPrimitiveNode(JSNodeTypes.TRUE, t.value.toString(), t.getStart(), t.getEnd());
				}
			},
			new Action() {	// [298] Literal = FALSE.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol f = _symbols[offset + 1];
					return new JSPrimitiveNode(JSNodeTypes.FALSE, f.value.toString(), f.getStart(), f.getEnd());
				}
			},
			new Action() {	// [299] Literal = NUMBER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					return new JSPrimitiveNode(JSNodeTypes.NUMBER, n, _symbol_n.getStart(), _symbol_n.getEnd());
				}
			},
			new Action() {	// [300] Literal = STRING.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					return new JSPrimitiveNode(JSNodeTypes.STRING, s, _symbol_s.getStart(), _symbol_s.getEnd());
				}
			},
			new Action() {	// [301] Literal = REGEX.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					return new JSPrimitiveNode(JSNodeTypes.REGEX, r, _symbol_r.getStart(), _symbol_r.getEnd());
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
