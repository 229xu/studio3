package com.aptana.editor.js.parsing;

import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "SDoc.grammar".
 */
@SuppressWarnings("unchecked")
public class SDocParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjbcji55KKn$yp#sXfbxQMMiGMUPIMxRfTjgq8AYBr0HJauGD5jFXMG0Nn3GeMZ1gCCT7" +
		"4nCH4lXZzfD54JJIn28g8HG4fWbWG544KYwX8LVJultVFJYVhfcxyHi8cl$EUCxTdxfqfu5" +
		"QY7qv22OfHX3BqHIbEHZaA4K01N6b31ORZKboD6x0Gzw4F#cC0gb2DAt4LhiC2F8Wb26Nl8" +
		"O9XrAVar2ENchoSgfPbMSs9oF4LAKSGez6CXFoDXv50A#OY7tDmFaQXdhwHO#GOBg1TZbEj" +
		"Nuv1Y62yjITXCA#RXZ3p4SGmdt88XhAcHZkSXt5sdoTmkgr9TRXUUnigRSrON$r4Ao#cDz1" +
		"6PrZ$4fnclIPsgVNwDk0AgmTZfZqBgp7BtkTcNKUXl8ThpNMoohUMMws#1tVY35eFwRsRiS" +
		"YhQSQzDZhFYqInsEecBCMvb4sOZ0cKSKpd78n$EMwYd8IxKKTzEnx022JHY94u4sVZB9p3s" +
		"Wjn4MKSKp2LyZ9o3Lemcok#aVOjk0rtu2vQzvC8ykKlE73vbWZoz8TvClDv6gFy#uTpderS" +
		"VGcVQIcVR9bzcltv5XZ0vrJ1gGxal0PnBcOEsNk0FOpEfKTkz$c$gpaHERuYPjSOp#4UIb0" +
		"cwIMOA#RNh92#aSNC5T4sjGNs$DIIL4KLumdQIPjt#VsAUZMf3X6#eOpdS8ywlcogTu7zSf" +
		"gQ8bzzaKg7vzP4NVLTwyLuVTph6zAzxwXszJwkToSJwUcIMLljMslOLnFMg$AyI42lYb77A" +
		"MFs$CVuZeXp3Zr#bMQ7KOSuxI3j6hv1WhPsX9Lf7R3KyxvHQpVO#e1cefoj#IrlfH2HlLHr" +
		"P0Xj0Pnfj1kfMrfj6UQeNcXqhl2tc3n2dYJFijyACe#ifFy2UPdsw#GTqaR$DRtkRRA6iPr" +
		"aFbb0lpsLSnQfFaAEglqIwLPxATckzWHoJEqfggcSPVzUgpETj9EPwZz67i#eUO9i9hFLVv" +
		"eyaxBTFDhFaUVfTEZViLFrFgtfm$ohr14wXpJNpHXFYTkN#Wto9fbA2dptxM2#M7kK#EBzD" +
		"5PA#mEoZbHgh8psHhA9L6izdxepYeppFQFnhAqmDX$z3gqRIiQgNPEkPNwFnYPcpgyt#3Ep" +
		"cKn6ardQOwxgCMH9Hdr0SsOEJwdDlUIi8ZFKtz3xFPqjFdkJpzwcskovhLckUpSrRoSzYxR" +
		"qVlBLV65YP9VwgqcdBx$MvDBxZFfHrIjyDPsgTVyuBMI$sXyIdabdjzbFlVsTMh$IPwyd1y" +
		"WhljWdv0VoblelaiDc1hwQWocDvSZuoK$I9GVbH$bJVfTkEIg$oH7vLNwHd#Mm$C4yEyltN" +
		"lK1rLto7UL#pzj7kKC#fzmgdr5ssFXcuVwKBMIZzJ#LxR9DE5$XccM3ZRNBEk54v6EotaO#" +
		"yhf#I$QIRxp8rvHxlDLqoMvPQosU3raZxpFobPVRvLbyqqWdzPToI2zjulzE3j#20ILet#k" +
		"rzXlmtoHPcxJV0zZlHe9#3w4CEzCtEfmr7#TQuknNfyGi0H$63$hY8P$EqroOvFDBuLWQB0" +
		"5FrzllOugH$m3w4wfb");

	// suppress parser error reporting and let the custom error recovery mechanism handle it
	private static class SDocEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}
	
	private SDocScanner fScanner;
	
	/**
	 * parse
	 *
	 * @param source
	 */
	public void parse(String source) throws java.lang.Exception
	{
		fScanner.setSource(source);
		parse(fScanner);
	}

	public SDocParser() {
		super(PARSING_TABLES);


	report = new SDocEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 1: // block = START_DOCUMENTATION text END_DOCUMENTATION
			{
					
			// TextBlock
			}
			case 2: // block = START_DOCUMENTATION tags END_DOCUMENTATION
			{
					
			// TagsBlock
			}
			case 3: // block = START_DOCUMENTATION text tags END_DOCUMENTATION
			{
					
			// Block
			}
			case 4: // text = text textPart
			{
					
			// AddText
			}
			case 5: // text = textPart
			{
					
			// PassThrough
			}
			case 6: // textPart = TEXT
			{
					
			// Text
			}
			case 7: // textPart = LBRACKET
			{
					
			// Text
			}
			case 8: // textPart = RBRACKET
			{
					
			// Text
			}
			case 9: // textPart = LCURLY
			{
					
			// Text
			}
			case 10: // textPart = RCURLY
			{
					
			// Text
			}
			case 11: // textPart = POUND
			{
					
			// Text
			}
			case 12: // textPart = IDENTIFIER
			{
					
			// Text
			}
			case 13: // textPart = COLON
			{
					
			// Text
			}
			case 14: // textPart = ERROR
			{
					
			// Text
			}
			case 15: // tags = tags tag
			{
					
			// AddTag
			}
			case 16: // tags = tag
			{
					
			// FirstTag
			}
			case 19: // tag = ADVANCED opt$text
			{
					
			// Advanced
			}
			case 20: // tag = ALIAS text
			{
					
			// Alias
			}
			case 21: // tag = AUTHOR text
			{
					
			// Author
			}
			case 22: // tag = CLASS_DESCRIPTION LCURLY namespace RCURLY text
			{
					
			// ClassDescription
			}
			case 23: // tag = CONSTRUCTOR opt$text
			{
					
			// Constructor
			}
			case 24: // tag = EXAMPLE text
			{
					
			// Example
			}
			case 25: // tag = EXCEPTION LCURLY types RCURLY opt$text
			{
					
			// Exception
			}
			case 26: // tag = EXTENDS LCURLY types RCURLY opt$text
			{
					
			// Extends
			}
			case 27: // tag = INTERNAL opt$text
			{
					
			// Internal
			}
			case 28: // tag = METHOD opt$text
			{
					
			// Method
			}
			case 29: // tag = NAMESPACE LCURLY namespace RCURLY opt$text
			{
					
			// Namespace
			}
			case 30: // tag = OVERVIEW text
			{
					
			// Overview
			}
			case 31: // tag = PARAM LCURLY types RCURLY paramName opt$text
			{
					
			// Param
			}
			case 32: // tag = PRIVATE opt$text
			{
					
			// Private
			}
			case 33: // tag = PROPERTY LCURLY types RCURLY opt$text
			{
					
			// Property
			}
			case 34: // tag = RETURN LCURLY types RCURLY opt$text
			{
					
			// Return
			}
			case 35: // tag = SEE text
			{
					
			// SeeText
			}
			case 36: // tag = UNKNOWN opt$text
			{
					
			// Unknown
			}
			case 37: // types = types typeDelimiter type
			{
					
			// AddType
			}
			case 38: // types = type
			{
					
			// FirstType
			}
			case 41: // type = IDENTIFIER
			{
					
			// Type
			}
			case 42: // type = IDENTIFIER LBRACKET RBRACKET
			{
					
			// SimpleArrayType
			}
			case 43: // type = ARRAY LBRACKET RBRACKET
			{
					
			// SimpleArrayType
			}
			case 44: // type = FUNCTION LBRACKET RBRACKET
			{
					
			// SimpleArrayType
			}
			case 45: // type = ARRAY
			{
					
			// Type
			}
			case 46: // type = ARRAY LESS_THAN type GREATER_THAN
			{
					
			// ComplexArrayType
			}
			case 47: // type = FUNCTION
			{
					
			// SimpleProcedure
			}
			case 48: // type = FUNCTION returnDelimiter type
			{
					
			// SimpleFunction
			}
			case 49: // type = FUNCTION returnDelimiter LPAREN types RPAREN
			{
					
			// SimpleFunctionComplexReturn
			}
			case 50: // type = FUNCTION LPAREN RPAREN
			{
					
			// SimpleProcedure
			}
			case 51: // type = FUNCTION LPAREN RPAREN returnDelimiter type
			{
					
			// SimpleFunction2
			}
			case 52: // type = FUNCTION LPAREN RPAREN returnDelimiter LPAREN types RPAREN
			{
					
			// SimpleFunctionComplexReturn2
			}
			case 53: // type = FUNCTION LPAREN types RPAREN
			{
					
			// Procedure
			}
			case 54: // type = FUNCTION LPAREN types RPAREN returnDelimiter type
			{
					
			// Function
			}
			case 55: // type = FUNCTION LPAREN types RPAREN returnDelimiter LPAREN types RPAREN
			{
					
			// FunctionComplexReturn
			}
			case 58: // paramName = TEXT
			{
					
			// ParamName
			}
			case 59: // paramName = LBRACKET TEXT RBRACKET
			{
					
			// OptionalParamName
			}
			case 60: // paramName = ELLIPSIS
			{
					
			// VarArgs
			}
			case 61: // paramName = LBRACKET ELLIPSIS RBRACKET
			{
					
			// OptionalVarArgs
			}
			case 17: // opt$text = 
			{
				return new Symbol(null);
			}
			case 0: // grammar = block
			case 18: // opt$text = text
			case 39: // typeDelimiter = COMMA
			case 40: // typeDelimiter = PIPE
			case 56: // returnDelimiter = COLON
			case 57: // returnDelimiter = ARROW
			case 62: // namespace = IDENTIFIER
			case 63: // namespace = FUNCTION
			case 64: // namespace = ARRAY
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
