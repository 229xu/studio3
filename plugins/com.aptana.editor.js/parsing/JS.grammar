%package "com.aptana.editor.js.parsing";
%class "JSParser";
%import "com.aptana.editor.js.parsing.ast.*";
%import "com.aptana.parsing.ast.ParseRootNode";
%import "java.util.List";
%import "java.util.ArrayList";

%terminals FUNCTION, IDENTIFIER, STRING, NUMBER, NULL, TRUE, FALSE, REGEX;
%terminals LCURLY, RCURLY, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, COLON, SEMICOLON, EQUAL, DOT, QUESTION;
%terminals IF, ELSE, DO, WHILE, FOR, IN, CONTINUE, BREAK, RETURN, WITH, SWITCH, CASE, DEFAULT, THROW, TRY, CATCH, FINALLY;
%terminals VAR, THIS, NEW, DELETE, PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, EXCLAMATION, TILDE, TYPEOF, VOID, AMPERSAND, CARET, PIPE, AMPERSAND_AMPERSAND, PIPE_PIPE;
%terminals STAR, FORWARD_SLASH, PERCENT, LESS_LESS, GREATER_GREATER, GREATER_GREATER_GREATER;
%terminals LESS, GREATER, LESS_EQUAL, GREATER_EQUAL, INSTANCEOF, IN, EQUAL_EQUAL, EXCLAMATION_EQUAL, EQUAL_EQUAL_EQUAL, EXCLAMATION_EQUAL_EQUAL;
%terminals EQUAL, STAR_EQUAL, FORWARD_SLASH_EQUAL, PERCENT_EQUAL, PLUS_EQUAL, MINUS_EQUAL, LESS_LESS_EQUAL, GREATER_GREATER_EQUAL, GREATER_GREATER_GREATER_EQUAL, AMPERSAND_EQUAL, CARET_EQUAL, PIPE_EQUAL;

%typeof NUMBER, STRING, REGEX, IDENTIFIER = "String";
%typeof AssignmentOperator, AdditiveOperator, MultiplicativeOperator, UnaryOperator, PostfixOperator, RelationalOperator, RelationalOperator_NoIn, ShiftOperator, EqualityOperator = "String";
%typeof AssignmentExpression, AssignmentExpression_NoIn, LeftHandSideExpression, LeftHandSideExpression_NoLBF, UnaryExpression = "JSNode";
%typeof AdditiveExpression, AdditiveExpression_NoLBF, MultiplicativeExpression, MultiplicativeExpression_NoLBF, RelationalExpression, RelationalExpression_NoIn, RelationalExpression_NoLBF = "JSNode";
%typeof ShiftExpression, ShiftExpression_NoLBF, EqualityExpression, EqualityExpression_NoIn, EqualityExpression_NoLBF = "JSNode";
%typeof LogicalAndExpression, LogicalAndExpression_NoIn, LogicalAndExpression_NoLBF, LogicalOrExpression, LogicalOrExpression_NoIn, LogicalOrExpression_NoLBF = "JSNode";
%typeof BitwiseOrExpression, BitwiseOrExpression_NoIn, BitwiseOrExpression_NoLBF, BitwiseXorExpression, BitwiseXorExpression_NoIn, BitwiseXorExpression_NoLBF, BitwiseAndExpression, BitwiseAndExpression_NoIn, BitwiseAndExpression_NoLBF = "JSNode";
%typeof MemberExpression, MemberExpression_NoLBF, NewExpression, CallExpression, CallExpression_NoLBF, Expression, Expression_NoIn, Expression_NoLBF, Statement, Statement_NoIf, Arguments, Block, Catch, Finally = "JSNode";
%typeof VariableDeclaration, VariableDeclaration_NoIn, PropertyName, PropertyNameAndValue, Elision, ElementList, FormalParameterList, FunctionParameters, FunctionBody, SourceElement = "JSNode";
%typeof CaseClause, DefaultClause = "JSNode";

%goal Program;

Program
	=	SourceElements.p {:return new ParseRootNode(IJSParserConstants.LANGUAGE, p, _symbol_p.getStart(), _symbol_p.getEnd());:}
	;

SourceElements
	=	SourceElements SourceElement
	|	SourceElement
	;

SourceElement
	=	FunctionDeclaration
	|	Statement
	;

FunctionDeclaration
	=	FUNCTION.f IDENTIFIER.i FunctionParameters.p FunctionBody.b {:return new JSFunctionNode(i, new JSNode[] { p, b }, f.getStart(), b.getEnd());:}
	;

FunctionExpression
	=	FUNCTION.f FunctionParameters.p FunctionBody.b {:return new JSFunctionNode(new JSNode[] { p, b }, f.getStart(), b.getEnd());:}
	|	FunctionDeclaration
	;

FunctionParameters
	=	LPAREN.l RPAREN.r {:return new JSNaryNode(JSNodeTypes.PARAMETERS, l.getStart(), r.getEnd());:}
	|	LPAREN.l FormalParameterList.p RPAREN.r {:p.setLocation(l.getStart(), r.getEnd());return p;:}
	;

FormalParameterList
	=	FormalParameterList.p COMMA IDENTIFIER.i {:JSNode node = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());p.addChild(node);p.setLocation(p.getStart(), node.getEnd());return p;:}
	|	IDENTIFIER.i {:JSNode node = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNaryNode(JSNodeTypes.PARAMETERS, new JSNode[] { node }, node.getStart(), node.getEnd());:}
	;

FunctionBody
	=	LCURLY.l RCURLY.r {:return new JSNaryNode(JSNodeTypes.STATEMENTS, l.getStart(), r.getEnd());:}
	|	LCURLY.l SourceElements.s RCURLY.r {:return new JSNaryNode(JSNodeTypes.STATEMENTS, s, l.getStart(), r.getEnd());:}
	;

Statement
	=	Block
	|	VAR.s VariableDeclarationList.l SEMICOLON.e {:JSNode node = new JSNaryNode(JSNodeTypes.VAR, l, s.getStart(), e.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	Expression_NoLBF.e SEMICOLON {:e.setSemicolonIncluded(true); return e;:}
	|	IfStatement
	|	IterationStatement
	|	ContinueStatement
	|	BreakStatement
	|	ReturnStatement
	|	WithStatement
	|	LabelledStatement
	|	SwitchStatement
	|	ThrowStatement
	|	TryStatement
	|	SEMICOLON.s {:return new JSNode(JSNodeTypes.EMPTY, s.getStart(), s.getEnd(), true);:}
	|	error.e {:return new JSNode(JSNodeTypes.ERROR, e.getStart(), e.getEnd());:}
	;

Statement_NoIf
	=	Block
	|	VAR.s VariableDeclarationList.l SEMICOLON.e {:JSNode node = new JSNaryNode(JSNodeTypes.VAR, l, s.getStart(), e.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	Expression_NoLBF.e SEMICOLON {:e.setSemicolonIncluded(true); return e;:}
	|	IfStatement_NoIf
	|	IterationStatement_NoIf
	|	ContinueStatement
	|	BreakStatement
	|	ReturnStatement
	|	WithStatement_NoIf
	|	LabelledStatement_NoIf
	|	SwitchStatement
	|	ThrowStatement
	|	TryStatement
	|	SEMICOLON.s {:return new JSNode(JSNodeTypes.EMPTY, s.getStart(), s.getEnd());:}
	|	error.e {:return new JSNode(JSNodeTypes.ERROR, e.getStart(), e.getEnd());:}
	;

Block
	=	LCURLY.l RCURLY.r {:return new JSNaryNode(JSNodeTypes.STATEMENTS, l.getStart(), r.getEnd());:}
	|	LCURLY.l StatementList.a RCURLY.r {:return new JSNaryNode(JSNodeTypes.STATEMENTS, a, l.getStart(), r.getEnd());:}
	;

StatementList
	=	StatementList Statement
	|	Statement
	;

VariableDeclarationList
	=	VariableDeclarationList COMMA VariableDeclaration
	|	VariableDeclaration
	;

VariableDeclarationList_NoIn
	=	VariableDeclarationList_NoIn COMMA VariableDeclaration_NoIn
	|	VariableDeclaration_NoIn
	;

VariableDeclaration
	=	IDENTIFIER.i {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.DECLARATION, new JSNode[] { id, new JSNode() }, _symbol_i.getStart(), _symbol_i.getEnd());:}
	|	IDENTIFIER.i EQUAL AssignmentExpression.e {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.DECLARATION, new JSNode[] { id, e }, _symbol_i.getStart(), e.getEnd());:}
	;

VariableDeclaration_NoIn
	=	IDENTIFIER.i {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.DECLARATION, new JSNode[] { id, new JSNode() }, _symbol_i.getStart(), _symbol_i.getEnd());:}
	|	IDENTIFIER.i EQUAL AssignmentExpression_NoIn.e {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.DECLARATION, new JSNode[] { id, e }, _symbol_i.getStart(), e.getEnd());:}
	;

IfStatement
	=	IF.i LPAREN Expression.e RPAREN Statement_NoIf.sn ELSE Statement.s {:return new JSNode(JSNodeTypes.IF, new JSNode[] { e, sn, s }, i.getStart(), s.getEnd());:}
	|	IF.i LPAREN Expression.e RPAREN Statement.s {:return new JSNode(JSNodeTypes.IF, new JSNode[] { e, s, new JSNode() }, i.getStart(), s.getEnd());:}
	;

IfStatement_NoIf
	=	IF.i LPAREN Expression.e RPAREN Statement_NoIf.sn ELSE Statement_NoIf.s {:return new JSNode(JSNodeTypes.IF, new JSNode[] { e, sn, s }, i.getStart(), s.getEnd());:}
	;

IterationStatement
	=	DO.d Statement.s WHILE LPAREN Expression.e RPAREN SEMICOLON.r {:JSNode node = new JSNode(JSNodeTypes.DO, new JSNode[] { s, e }, d.getStart(), r.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	WHILE.w LPAREN Expression.e RPAREN Statement.s {:return new JSNode(JSNodeTypes.WHILE, new JSNode[] { e, s }, w.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON SEMICOLON RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON Expression.c SEMICOLON RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement.s  {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN LeftHandSideExpression.i IN Expression.o RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR_IN, new JSNode[] { i, o, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclaration_NoIn.i IN Expression.o RPAREN Statement.s {:return new JSNode(JSNodeTypes.FOR_IN, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, new JSNode[] { i }, v.getStart(), i.getEnd()), o, s }, f.getStart(), s.getEnd());:}
	;

IterationStatement_NoIf
	=	DO.d Statement.s WHILE LPAREN Expression.e RPAREN SEMICOLON.r {:JSNode node = new JSNode(JSNodeTypes.DO, new JSNode[] { s, e }, d.getStart(), r.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	WHILE.w LPAREN Expression.e RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.WHILE, new JSNode[] { e, s }, w.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNode(), c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { i, c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), new JSNode(), new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), new JSNode(), a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), c, new JSNode(), s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, i, v.getStart(), i[i.length - 1].getEnd()), c, a, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN LeftHandSideExpression.i IN Expression.o RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR_IN, new JSNode[] { i, o, s }, f.getStart(), s.getEnd());:}
	|	FOR.f LPAREN VAR.v VariableDeclaration_NoIn.i IN Expression.o RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.FOR_IN, new JSNode[] { new JSNaryNode(JSNodeTypes.VAR, new JSNode[] {i }, v.getStart(), i.getEnd()), o, s }, f.getStart(), s.getEnd());:}
	;

ContinueStatement
	=	CONTINUE.c SEMICOLON.s {:JSNode node = new JSLabelStatementNode(JSNodeTypes.CONTINUE, c.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	CONTINUE.c IDENTIFIER.i SEMICOLON.s {:JSNode node = new JSLabelStatementNode(JSNodeTypes.CONTINUE, i, c.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	;

BreakStatement
	=	BREAK.b SEMICOLON.s {:JSNode node = new JSLabelStatementNode(JSNodeTypes.BREAK, b.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	BREAK.b IDENTIFIER.i SEMICOLON.s {:JSNode node = new JSLabelStatementNode(JSNodeTypes.BREAK, i, b.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	;

ReturnStatement
	=	RETURN.r SEMICOLON.s {:JSNode node = new JSUnaryOperatorNode(JSNodeTypes.RETURN, new JSNode(), r.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	|	RETURN.r Expression.e SEMICOLON.s {:JSNode node = new JSUnaryOperatorNode(JSNodeTypes.RETURN, e, r.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	;

WithStatement
	=	WITH.w LPAREN Expression.e RPAREN Statement.s {:return new JSNode(JSNodeTypes.WITH, new JSNode[] { e, s }, w.getStart(), s.getEnd());:}
	;

WithStatement_NoIf
	=	WITH.w LPAREN Expression.e RPAREN Statement_NoIf.s {:return new JSNode(JSNodeTypes.WITH, new JSNode[] { e, s }, w.getStart(), s.getEnd());:}
	;

SwitchStatement
	=	SWITCH.s LPAREN Expression.e RPAREN LCURLY RCURLY.r {:return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, s.getStart(), r.getEnd());:}
	|	SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c RCURLY.r {:return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, c, s.getStart(), r.getEnd());:}
	|	SWITCH.s LPAREN Expression.e RPAREN LCURLY DefaultClause.d RCURLY.r {:return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, new JSNode[] { d }, s.getStart(), r.getEnd());:}
	|	SWITCH.s LPAREN Expression.e RPAREN LCURLY DefaultClause.d CaseClauses.c RCURLY.r {:
			List<JSNode> children = new ArrayList<JSNode>();
			children.add(d);
			for (JSNode statement : c) {
				children.add(statement);
			}
			return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, children.toArray(new JSNode[children.size()]), s.getStart(), r.getEnd());:}
	|	SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c DefaultClause.d RCURLY.r {:
			List<JSNode> children = new ArrayList<JSNode>();
			for (JSNode statement : c) {
				children.add(statement);
			}
			children.add(d);
			return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, children.toArray(new JSNode[children.size()]), s.getStart(), r.getEnd());:}
	|	SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c1 DefaultClause.d CaseClauses.c2 RCURLY.r {:
			List<JSNode> children = new ArrayList<JSNode>();
			for (JSNode statement : c1) {
				children.add(statement);
			}
			children.add(d);
			for (JSNode statement : c2) {
				children.add(statement);
			}
			return new JSNaryAndExpressionNode(JSNodeTypes.SWITCH, e, children.toArray(new JSNode[children.size()]), s.getStart(), r.getEnd());:}
	;

CaseClauses
	=	CaseClauses CaseClause
	|	CaseClause
	;

CaseClause
	=	CASE.c Expression.e COLON.r {:return new JSNaryAndExpressionNode(JSNodeTypes.CASE, e, c.getStart(), r.getEnd());:}
	|	CASE.c Expression.e COLON StatementList.s {:return new JSNaryAndExpressionNode(JSNodeTypes.CASE, e, s, c.getStart(), s[s.length - 1].getEnd());:}
	;

DefaultClause
	=	DEFAULT.d COLON.c {:return new JSNaryNode(JSNodeTypes.DEFAULT, d.getStart(), c.getEnd());:}
	|	DEFAULT.d COLON StatementList.s {:return new JSNaryNode(JSNodeTypes.DEFAULT, s, d.getStart(), s[s.length - 1].getEnd());:}
	;

LabelledStatement
	=	IDENTIFIER.i COLON Statement.s {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.LABELLED, new JSNode[] { id, s }, _symbol_i.getStart(), s.getEnd());:}
	;

LabelledStatement_NoIf
	=	IDENTIFIER.i COLON Statement_NoIf.s {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.LABELLED, new JSNode[] { id, s }, _symbol_i.getStart(), s.getEnd());:}
	;

ThrowStatement
	=	THROW.t Expression.e SEMICOLON.s {:JSNode node = new JSUnaryOperatorNode(JSNodeTypes.THROW, e, t.getStart(), s.getEnd());node.setSemicolonIncluded(true);return node;:}
	;

TryStatement
	=	TRY.t Block.b Catch.c {:return new JSNode(JSNodeTypes.TRY, new JSNode[] { b, c, new JSNode() }, t.getStart(), c.getEnd());:}
	|	TRY.t Block.b Finally.f {:return new JSNode(JSNodeTypes.TRY, new JSNode[] { b, new JSNode(), f }, t.getStart(), f.getEnd());:}
	|	TRY.t Block.b Catch.c Finally.f {:return new JSNode(JSNodeTypes.TRY, new JSNode[] { b, c, f }, t.getStart(), f.getEnd());:}
	;

Catch
	=	CATCH.c LPAREN IDENTIFIER.i RPAREN Block.b {:JSNode id = new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());return new JSNode(JSNodeTypes.CATCH, new JSNode[] { id, b }, c.getStart(), b.getEnd());:}
	;

Finally
	=	FINALLY.f Block.b {:return new JSNode(JSNodeTypes.FINALLY, new JSNode[] { b }, f.getStart(), b.getEnd());:}
	;

PrimaryExpression
	=	PrimaryExpression_NoLBF
	|	ObjectLiteral
	;

PrimaryExpression_NoLBF
	=	THIS.t {:return new JSPrimitiveNode(JSNodeTypes.THIS, t.value.toString(), t.getStart(), t.getEnd());:}
	|	IDENTIFIER.t {:return new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, t, _symbol_t.getStart(), _symbol_t.getEnd());:}
	|	Literal
	|	ArrayLiteral
	|	LPAREN.l Expression.e RPAREN.r {:return new JSUnaryOperatorNode(JSNodeTypes.GROUP, e, l.getStart(), r.getEnd());:}
	;

ArrayLiteral
	=	LBRACKET.l RBRACKET.r {:return new JSNaryNode(JSNodeTypes.ARRAY_LITERAL, l.getStart(), r.getEnd());:}
	|	LBRACKET.l Elision.e RBRACKET.r {:return new JSNaryNode(JSNodeTypes.ARRAY_LITERAL, new JSNode[] { e }, l.getStart(), r.getEnd());:}
	|	LBRACKET.l ElementList.e RBRACKET.r {:return new JSNaryNode(JSNodeTypes.ARRAY_LITERAL, new JSNode[] { e }, l.getStart(), r.getEnd());:}
	|	LBRACKET.l ElementList.e COMMA RBRACKET.r  {:return new JSNaryNode(JSNodeTypes.ARRAY_LITERAL, new JSNode[] { e, new JSPrimitiveNode(JSNodeTypes.NULL, "null", 0, 0) }, l.getStart(), r.getEnd());:}
	|	LBRACKET.l ElementList.e COMMA Elision.n RBRACKET.r {:return new JSNaryNode(JSNodeTypes.ARRAY_LITERAL, new JSNode[] { e, n }, l.getStart(), r.getEnd());:}
	;

ElementList
	=	AssignmentExpression.e {:return new JSNaryNode(JSNodeTypes.ELEMENTS, new JSNode[] { e }, e.getStart(), e.getEnd());:}
	|	Elision.n AssignmentExpression.e {:return new JSNaryNode(JSNodeTypes.ELEMENTS, new JSNode[] { n, e }, n.getStart(), e.getEnd());:}
	|	ElementList.l COMMA AssignmentExpression.e {:l.addChild(e);l.setLocation(l.getStart(), e.getEnd());return l;:}
	|	ElementList.l COMMA Elision.n AssignmentExpression.e {:l.addChild(n);l.addChild(e);l.setLocation(l.getStart(), e.getEnd());return l;:}
	;

Elision
	=	Elision.e COMMA {:e.addChild(new JSPrimitiveNode(JSNodeTypes.NULL, "null", 0, 0));return e;:}
	|	COMMA {:return new JSNaryNode(JSNodeTypes.ELISION, new JSNode[] { new JSPrimitiveNode(JSNodeTypes.NULL, "null", 0, 0), new JSPrimitiveNode(JSNodeTypes.NULL, "null", 0, 0) }, 0, 0);:}
	;

ObjectLiteral
	=	LCURLY.l RCURLY.r {:return new JSNaryNode(JSNodeTypes.OBJECT_LITERAL, l.getStart(), r.getEnd());:}
	|	LCURLY.l PropertyNameAndValueList.p RCURLY.r {:return new JSNaryNode(JSNodeTypes.OBJECT_LITERAL, p, l.getStart(), r.getEnd());:}
	;

PropertyNameAndValueList
	=	PropertyNameAndValue
	|	PropertyNameAndValueList COMMA PropertyNameAndValue
	;

PropertyNameAndValue
	=	PropertyName.n COLON AssignmentExpression.v {:return new JSNode(JSNodeTypes.NAME_VALUE_PAIR, new JSNode[] { n, v }, n.getStart(), v.getEnd());:}
	;

PropertyName
	=	IDENTIFIER.i {:return new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, i, _symbol_i.getStart(), _symbol_i.getEnd());:}
	|	STRING.s {:return new JSPrimitiveNode(JSNodeTypes.STRING, s, _symbol_s.getStart(), _symbol_s.getEnd());:}
	|	NUMBER.n {:return new JSPrimitiveNode(JSNodeTypes.NUMBER, n, _symbol_n.getStart(), _symbol_n.getEnd());:}
	;

MemberExpression
	=	PrimaryExpression
	|	FunctionExpression
	|	MemberExpression.l LBRACKET Expression.r RBRACKET {:return new JSGetElementOperatorNode(l, r);:}
	|	MemberExpression.l DOT IDENTIFIER.r {:return new JSGetPropertyOperatorNode(l, new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, r, _symbol_r.getStart(), _symbol_r.getEnd()));:}
	|	NEW.l MemberExpression.e Arguments.a {:return new JSNode(JSNodeTypes.CONSTRUCT, new JSNode[] { e, a }, l.getStart(), a.getEnd());:}
	;

MemberExpression_NoLBF
	=	PrimaryExpression_NoLBF
	|	MemberExpression_NoLBF.l LBRACKET Expression.r RBRACKET {:return new JSGetElementOperatorNode(l, r);:}
	|	MemberExpression_NoLBF.l DOT IDENTIFIER.r {:return new JSGetPropertyOperatorNode(l, new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, r, _symbol_r.getStart(), _symbol_r.getEnd()));:}
	|	NEW.l MemberExpression.e Arguments.a {:return new JSNode(JSNodeTypes.CONSTRUCT, new JSNode[] { e, a }, l.getStart(), a.getEnd());:}
	;

NewExpression
	=	MemberExpression
	|	NEW.l NewExpression.e {:return new JSNode(JSNodeTypes.CONSTRUCT, new JSNode[] { e, new JSNode() }, l.getStart(), e.getEnd());:}
	;

NewExpression_NoLBF
	=	MemberExpression_NoLBF
	|	NEW.l NewExpression.e {:return new JSNode(JSNodeTypes.CONSTRUCT, new JSNode[] { e, new JSNode() }, l.getStart(), e.getEnd());:}
	;

CallExpression
	=	MemberExpression.l Arguments.r {:return new JSNode(JSNodeTypes.INVOKE, new JSNode[] {l, r}, l.getStart(), r.getEnd());:}
	|	CallExpression.l Arguments.r {:return new JSNode(JSNodeTypes.INVOKE, new JSNode[] {l, r}, l.getStart(), r.getEnd());:}
	|	CallExpression.l LBRACKET Expression.r RBRACKET {:return new JSGetElementOperatorNode(l, r);:}
	|	CallExpression.l DOT IDENTIFIER.r {:return new JSGetPropertyOperatorNode(l, new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, r, _symbol_r.getStart(), _symbol_r.getEnd()));:}
	;

CallExpression_NoLBF
	=	MemberExpression_NoLBF.l Arguments.r {:return new JSNode(JSNodeTypes.INVOKE, new JSNode[] {l, r}, l.getStart(), r.getEnd());:}
	|	CallExpression_NoLBF.l Arguments.r {:return new JSNode(JSNodeTypes.INVOKE, new JSNode[] {l, r}, l.getStart(), r.getEnd());:}
	|	CallExpression_NoLBF.l LBRACKET Expression.r RBRACKET {:return new JSGetElementOperatorNode(l, r);:}
	|	CallExpression_NoLBF.l DOT IDENTIFIER.r {:return new JSGetPropertyOperatorNode(l, new JSPrimitiveNode(JSNodeTypes.IDENTIFIER, r, _symbol_r.getStart(), _symbol_r.getEnd()));:}
	;

Arguments
	=	LPAREN.l RPAREN.r {:return new JSNaryNode(JSNodeTypes.ARGUMENTS, l.getStart(), r.getEnd());:}
	|	LPAREN.l ArgumentList.a RPAREN.r {:return new JSNaryNode(JSNodeTypes.ARGUMENTS, a, l.getStart(), r.getEnd());:}
	;

ArgumentList
	=	ArgumentList COMMA AssignmentExpression
	|	AssignmentExpression
	;

LeftHandSideExpression
	=	NewExpression
	|	CallExpression
	;

LeftHandSideExpression_NoLBF
	=	NewExpression_NoLBF
	|	CallExpression_NoLBF
	;

PostfixExpression
	=	LeftHandSideExpression
	|	LeftHandSideExpression.e PostfixOperator.o {:return new JSPostUnaryOperatorNode(e, o, e.getStart(), _symbol_o.getEnd());:}
	;

PostfixExpression_NoLBF
	=	LeftHandSideExpression_NoLBF
	|	LeftHandSideExpression_NoLBF.e PostfixOperator.o {:return new JSPostUnaryOperatorNode(e, o, e.getStart(),  _symbol_o.getEnd());:}
	;

PostfixOperator
	=	PLUS_PLUS
	|	MINUS_MINUS
	;

UnaryExpression
	=	PostfixExpression
	|	UnaryOperator.o UnaryExpression.e {:return new JSUnaryOperatorNode(o, e, _symbol_o.getStart(), e.getEnd());:}
	;

UnaryExpression_NoLBF
	=	PostfixExpression_NoLBF
	|	UnaryOperator.o UnaryExpression.e {:return new JSUnaryOperatorNode(o, e, _symbol_o.getStart(), e.getEnd());:}
	;

UnaryOperator
	=	DELETE
	|	EXCLAMATION
	|	MINUS
	|	MINUS_MINUS
	|	PLUS
	|	PLUS_PLUS
	|	TILDE
	|	TYPEOF
	|	VOID
	;

MultiplicativeExpression
	=	UnaryExpression
	|	MultiplicativeExpression.l MultiplicativeOperator.o UnaryExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

MultiplicativeExpression_NoLBF
	=	UnaryExpression_NoLBF
	|	MultiplicativeExpression_NoLBF.l MultiplicativeOperator.o UnaryExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

MultiplicativeOperator
	=	STAR
	|	FORWARD_SLASH
	|	PERCENT
	;

AdditiveExpression
	=	MultiplicativeExpression
	|	AdditiveExpression.l AdditiveOperator.o MultiplicativeExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

AdditiveExpression_NoLBF
	=	MultiplicativeExpression_NoLBF
	|	AdditiveExpression_NoLBF.l AdditiveOperator.o MultiplicativeExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

AdditiveOperator
	=	PLUS
	|	MINUS
	;

ShiftExpression
	=	AdditiveExpression
	|	ShiftExpression.l ShiftOperator.o AdditiveExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

ShiftExpression_NoLBF
	=	AdditiveExpression_NoLBF
	|	ShiftExpression_NoLBF.l ShiftOperator.o AdditiveExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

ShiftOperator
	=	LESS_LESS
	|	GREATER_GREATER
	|	GREATER_GREATER_GREATER
	;

RelationalExpression
	=	ShiftExpression
	|	RelationalExpression.l RelationalOperator.o ShiftExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

RelationalExpression_NoLBF
	=	ShiftExpression_NoLBF
	|	RelationalExpression_NoLBF.l RelationalOperator.o ShiftExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

RelationalExpression_NoIn
	=	ShiftExpression
	|	RelationalExpression_NoIn.l RelationalOperator_NoIn.o ShiftExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

RelationalOperator_NoIn
	=	LESS
	|	GREATER
	|	LESS_EQUAL
	|	GREATER_EQUAL
	|	INSTANCEOF
	;

RelationalOperator
	=	RelationalOperator_NoIn
	|	IN
	;

EqualityExpression
	=	RelationalExpression
	|	EqualityExpression.l EqualityOperator.o RelationalExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

EqualityExpression_NoLBF
	=	RelationalExpression_NoLBF
	|	EqualityExpression_NoLBF.l EqualityOperator.o RelationalExpression.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

EqualityExpression_NoIn
	=	RelationalExpression_NoIn
	|	EqualityExpression_NoIn.l EqualityOperator.o RelationalExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o, r);:}
	;

EqualityOperator
	=	EQUAL_EQUAL
	|	EXCLAMATION_EQUAL
	|	EQUAL_EQUAL_EQUAL
	|	EXCLAMATION_EQUAL_EQUAL
	;

BitwiseAndExpression
	=	BitwiseAndExpression.l AMPERSAND.o EqualityExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	EqualityExpression
	;

BitwiseAndExpression_NoLBF
	=	BitwiseAndExpression_NoLBF.l AMPERSAND.o EqualityExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	EqualityExpression_NoLBF
	;

BitwiseAndExpression_NoIn
	=	BitwiseAndExpression_NoIn.l AMPERSAND.o EqualityExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	EqualityExpression_NoIn
	;

BitwiseXorExpression
	=	BitwiseXorExpression.l CARET.o BitwiseAndExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseAndExpression
	;

BitwiseXorExpression_NoLBF
	=	BitwiseXorExpression_NoLBF.l CARET.o BitwiseAndExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseAndExpression_NoLBF
	;

BitwiseXorExpression_NoIn
	=	BitwiseXorExpression_NoIn.l CARET.o BitwiseAndExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseAndExpression_NoIn
	;

BitwiseOrExpression
	=	BitwiseOrExpression.l PIPE.o BitwiseXorExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseXorExpression
	;

BitwiseOrExpression_NoLBF
	=	BitwiseOrExpression_NoLBF.l PIPE.o BitwiseXorExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseXorExpression_NoLBF
	;

BitwiseOrExpression_NoIn
	=	BitwiseOrExpression_NoIn.l PIPE.o BitwiseXorExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseXorExpression_NoIn
	;

LogicalAndExpression
	=	LogicalAndExpression.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseOrExpression
	;

LogicalAndExpression_NoLBF
	=	LogicalAndExpression_NoLBF.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseOrExpression_NoLBF
	;

LogicalAndExpression_NoIn
	=	LogicalAndExpression_NoIn.l AMPERSAND_AMPERSAND.o BitwiseOrExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	BitwiseOrExpression_NoIn
	;

LogicalOrExpression
	=	LogicalOrExpression.l PIPE_PIPE.o LogicalAndExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	LogicalAndExpression
	;

LogicalOrExpression_NoLBF
	=	LogicalOrExpression_NoLBF.l PIPE_PIPE.o LogicalAndExpression.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	LogicalAndExpression_NoLBF
	;

LogicalOrExpression_NoIn
	=	LogicalOrExpression_NoIn.l PIPE_PIPE.o LogicalAndExpression_NoIn.r {:return new JSBinaryOperatorNode(l, o.value.toString(), r);:}
	|	LogicalAndExpression_NoIn
	;

ConditionalExpression
	=	LogicalOrExpression
	|	LogicalOrExpression.l QUESTION AssignmentExpression.t COLON AssignmentExpression.f {:return new JSNode(JSNodeTypes.CONDITIONAL, new JSNode[] { l, t, f }, l.getStart(), f.getEnd());:}
	;

ConditionalExpression_NoLBF
	=	LogicalOrExpression_NoLBF
	|	LogicalOrExpression_NoLBF.l QUESTION AssignmentExpression.t COLON AssignmentExpression.f {:return new JSNode(JSNodeTypes.CONDITIONAL, new JSNode[] { l, t, f }, l.getStart(), f.getEnd());:}
	;

ConditionalExpression_NoIn
	=	LogicalOrExpression_NoIn
	|	LogicalOrExpression_NoIn.l QUESTION AssignmentExpression_NoIn.t COLON AssignmentExpression_NoIn.f {:return new JSNode(JSNodeTypes.CONDITIONAL, new JSNode[] { l, t, f }, l.getStart(), f.getEnd());:}
	;

AssignmentExpression
	=	ConditionalExpression
	|	LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression.r {:return new JSAssignmentNode(l, o, r);:}
	;

AssignmentExpression_NoLBF
	=	ConditionalExpression_NoLBF
	|	LeftHandSideExpression_NoLBF.l AssignmentOperator.o AssignmentExpression.r {:return new JSAssignmentNode(l, o, r);:}
	;

AssignmentExpression_NoIn
	=	ConditionalExpression_NoIn
	|	LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression_NoIn.r {:return new JSAssignmentNode(l, o, r);:}
	;

AssignmentOperator
	=	EQUAL
	|	STAR_EQUAL
	|	FORWARD_SLASH_EQUAL
	|	PERCENT_EQUAL
	|	PLUS_EQUAL
	|	MINUS_EQUAL
	|	LESS_LESS_EQUAL
	|	GREATER_GREATER_EQUAL
	|	GREATER_GREATER_GREATER_EQUAL
	|	AMPERSAND_EQUAL
	|	CARET_EQUAL
	|	PIPE_EQUAL
	;

Expression
	=	Expression.l COMMA AssignmentExpression.r {:return new JSNaryNode(JSNodeTypes.COMMA, new JSNode[] { l, r }, l.getStart(), r.getEnd());:}
	|	AssignmentExpression
	;

Expression_NoLBF
	=	Expression_NoLBF.l COMMA AssignmentExpression.r {:return new JSNaryNode(JSNodeTypes.COMMA, new JSNode[] { l, r }, l.getStart(), r.getEnd());:}
	|	AssignmentExpression_NoLBF
	;

Expression_NoIn
	=	Expression_NoIn.l COMMA AssignmentExpression_NoIn.r {:return new JSNaryNode(JSNodeTypes.COMMA, new JSNode[] { l, r }, l.getStart(), r.getEnd());:}
	|	AssignmentExpression_NoIn
	;

Literal
	=	NULL.n {:return new JSPrimitiveNode(JSNodeTypes.NULL, n.value.toString(), n.getStart(), n.getEnd());:}
	|	TRUE.t {:return new JSPrimitiveNode(JSNodeTypes.TRUE, t.value.toString(), t.getStart(), t.getEnd());:}
	|	FALSE.f {:return new JSPrimitiveNode(JSNodeTypes.FALSE, f.value.toString(), f.getStart(), f.getEnd());:}
	|	NUMBER.n {:return new JSPrimitiveNode(JSNodeTypes.NUMBER, n, _symbol_n.getStart(), _symbol_n.getEnd());:}
	|	STRING.s {:return new JSPrimitiveNode(JSNodeTypes.STRING, s, _symbol_s.getStart(), _symbol_s.getEnd());:}
	|	REGEX.r {:return new JSPrimitiveNode(JSNodeTypes.REGEX, r, _symbol_r.getStart(), _symbol_r.getEnd());:}
	;
