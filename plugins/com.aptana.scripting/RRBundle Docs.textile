h1. Disclaimer

The Bundle runtime described in this document is under active development and subject to major changes without notice. The bundle runtime itself is part of RadRails and as such is distributed under the GPL v3 and the Aptana Source License. You are, of course, welcome to distribute your own bundles under any license you like.

h1. Runtime Architecture

RadRails can be extended via bundles of commands and snippets. Bundles are implemented in pure Ruby, using a JRuby runtime embedded in RadRails. Design-level compatibility with TextMate was a priority in the design - we wanted to make it reasonably straightforward to convert an existing TextMate bundle into a RadRails bundle, while still allowing commands and snippets to be more concise and more powerful. At the same time, we wanted RadRails to run on Linux and Windows as well as the Mac, so we had to make some changes to deal with issues like key bindings and OS-specific assumptions.

The RadRails runtime includes a @radrails.rb@ file that defines a DSL that can be used to create bundles, commands, and menus. @radrails.rb@ must be included via a @require@ in each file within the Bundle that defines bundles, commands, or snippets.

h2. Bundles

Bundles are the top-level distribution format for RadRails extensions. A bundle directory must contain a @bundle.rb@ at the top level. The @bundle.rb@ file defines the metadata for the bundle and its menu(s). By convention, the name of a bundle director ends with a @.rrbundle@ suffix but this is not required.

In addition to the @bundle.rb@ file, there are two top-level directories within a bundle that are treated specially:

| @commands/@	| contains the commands that make up the bundle. @.rb@ files within this directory will be loaded at startup, so you should keep it as minimal as possible to keep things fast. |
| @lib/@		| contains Ruby code that is on the load path when executing commands within your bundle. Put code here you wish to invoke from within your commands, but which you do not want loaded at startup. |

By convention, there are several other files and directories found in most bundles:

| @README@		| your usual README file (these also work: @README.md@, @README.markdown@, @README.textile@, and/or @README.txt@) |
| @Rakefile@	| your Rakefile, typically used for testing, packaging, and so forth |
| @assets/@		| images, icons, and other files used by your bundle |
| @test/@		| test code |

Note that we are considering a change to the bundle format to turn all bundles into gems. If we decide to implement this functionality the underlying structure will change to become gem compatible.

h3. Bundle Loading

Bundles are loaded from the file system in a hierarchical order. The order, from highest to lowest priority, is:

* The current project's "Bundle" subdirectory
* The "$USER_DOCUMENT_DIRECTORY/RadRails Bundles/", where "$USER_DOCUMENT_DIRECTORY" is platform dependent.
* The bundles directory within the RadRails installation

When a bundle is defined in multiple places, only the bundle code defined in the highest priority location is used. In this way, you can easily do a 'git clone' (or the equivalent) of a bundle from within your "$USER_DOCUMENT_DIRECTORY/RadRails Bundles/" and it will override the ones built in to RadRails itself.

h3. Extending Bundles From Other Bundles

It is possible for a bundle to override or extend another bundle's functionality. This is quite handy when you want to add a command or two to the menu of the existing bundle without having to maintain your own clone of a bundle repository.

It is possible for a bundle to override or extend another bundle's functionality. This is quite handy when you want to add a command or two to the menu of the existing bundle without having to maintain your own clone of a bundle repository.

Example

<pre>
# $USER_DOCUMENT_DIRECTORY/RadRails Bundles//MyBundle/bundle.rb
bundle "MyBundle" do |b|
  command "A" do |cmd|
    # ...
  end

  command "B" do |cmd|
    # ...
  end
end

# $PROJECT_DIRECTORY/bundles/MyBundle/bundle.rb
bundle "MyBundle" do |b|
  command "A" do |cmd|
    # ...
  end

  command "C" do |cmd|
    # ...
  end
end
</pre>

This example shows two separate bundle directories. The first bundle.rb file defines a bundle named "MyBundle" in the user's bundles directory. The second bundle.rb file defines a bundle of the same name, but within a project's bundles directory.

Bundle names are globally unique. This means that both files are referencing the same bundle. Since the user bundle is loaded first, the "MyBundle" bundle will contain two commands: A and B. Next, the project bundle will be loaded. It also defines an "A" command, so its definition will replace the user bundle's definition. The "B" command will remain and the "C" command will be added. As a result, "MyBundle" will consist of three commands: A, B, and C where A is the instance defined in the project bundle.

h2. Scopes

A scope specifies a context within the IDE. For example, when editing a document, the current cursor position within that document has a context associated with it. These scopes are supplied by the IDE and may be queried using the Shift-Control-P key command.

Our bundle runtime contains an implementation of scopes that is intended to be "compatible with TextMate's":http://manual.macromates.com/en/scope_selectors.

h3. Scope Selectors

A scope selector describes a pattern of scopes and is composed of dotted names, descendant operators, and grouping operators. In its simplest form, the scope selector consists of a single name.

Example - Simple Name Pattern

<pre>
text
</pre>

A scope selector needs only to match the prefix of a name to be considered a match. In the above example, the selector will match "text", "text.html", "text.html.ruby"; however, it will not match "texts.physics". A prefix match must end at dot within the scope or at the end of the scope itself.

Example - Descendant Pattern

<pre>
text.html source.ruby
</pre>

A scope may be defined as a hierarchy of scopes. In this sense, scope selectors match against that hierarchy much like CSS matches against and HTML DOM. In the above example, the selector will match when the editor's cursor is within Ruby code which is within HTML. The same matching rules described in the simple name pattern apply to each dotted name. For instance, the last example will match "text.html.ruby source.ruby.embedded.html" since "text.html" is a prefix for "text.html" and likewise "source.ruby" is a prefix for "source.ruby.embedded.html".

It is important to note that descendant matching progresses right-to-left. If, in our example, we had defined our selector as simply "source.ruby", then we would not only match the previous case where Ruby was embedded within HTML, but we would also match any cursor location that is within any Ruby source, regardless of nesting.

Example - Group Pattern

<pre>
text.html.ruby, text.html source.ruby
</pre>

In this example, our selector defines a list of selectors to be used for matching. The comma serves as an OR operator. Specifically, this selector is saying match "text.html.ruby" OR "text.html source.ruby". All matching rules described previously apply; however, if an alternation fails, matching will restart using the next alternation. Matching ends when either an alternation returns success or if all alternations have been exhausted.

h3. Menus Scope Selectors

It is important to note that scope selectors work left-to-right when matching a menu scope. For example, if we have a menu scope of "text.html", this will match when the cursor is within HTML but also when the cursor is within Ruby which is within HTML.

h2. Commands

Commands are the fundamental building blocks of Bundles. A command has the following properties:

| Element		| Required?		| Description |
| @name@		| Yes			| A human-readable name for the command. Must be unique within the bundle. |
| @invoke@	    | Yes			| The code to be executed. If specified as a string, it is executed as a shell script. If passed a block, it is invoked as a block when the command is executed. |
| @scope@		| 				| The scope in which the command can be executed. If no scope is specified, the command is assumed to be active in all scopes. |
| @input@		|				| The input to the command. See the _Input Definition_ section below. |
| @output@	    | 	 			| The output of the command. See the _Output Definition_ section below. |
| @key_binding@	| 	 			| The keyboard binding for the command. It is also possible to define platform-specific key bindings, as described in the _Key Bindings_ section below. |
| @trigger@	    |				| A tab trigger that will invoke the command if typed into an editor window and then the <TAB> key is pressed. It is possible to define both a trigger and a key_binding for a single command. |

Example command:

<pre>
<code programming-language="ruby">
command "Documentation for Word" do |cmd|
  cmd.scope = "source.ruby.rails, text.html.ruby, text.haml"

  cmd.key_binding = [ :control, "h" ]
  cmd.key_binding[:mac] =  [ :command, "h" ]

  cmd.input = [ :selection, :word ]
  cmd.output = :show_as_html

  cmd.invoke do |context|
    url = "http://apidock.com/rails/search/quick?query=" + CGI.escape(context.input)
    context.browser.open url, :new_window => true
  end
end
</code>
</pre>

h2. Snippets

Snippets are a specialized form of commands, designed to make it easier to specify the behavior of tab triggers. Snippets have a name, a scope, a trigger, and an expansion. You can think of these two declarations as being equivalent:

<pre>
<code programming-language="ruby">
snippet "My Snippet" do |snip|
  snip.trigger = "foo"
  snip.expansion = "my_super_snippet"
end

command "My Snippet" do |cmd|
  cmd.trigger = "foo"
  cmd.expansion = "my_super_snippet"

  cmd.input = :none
  cmd.output = :insert_as_snippet

  cmd.invoke do |context|
    context.output = cmd.expansion
  end
end
</code>
</pre>

Here are the properties specific to snippets. Note that the @trigger@ is required, unlike the case for commands.

| Element		| Required?		| Description |
| @name@		| Yes			| A human-readable name for the command. Must be unique within the bundle. |
| @scope@		| 				| The scope in which the command can be executed. If no scope is specified, the command is assumed to be active in all scopes. |
| @trigger@	    | Yes			| A tab trigger that will invoke the command if typed into an editor window and then the <TAB> key is pressed. It is possible to define both a trigger and a key_binding for a single command. |
| @expansion@	| Yes			| The snippet text that will be substituted for the command trigger. |

FORTHCOMING: the syntax for the expansion string (which roughly follows TextMate, but doesn't support nesting at present)

h1. Conventions and Definitions

Several properties defined in this document can have a variety of different values, and these types of values are defined by names in ALL_CAPS. Specifiers that are used in multiple places within this document are defined in this section.

h2. PATH_SPECIFIER

Paths can be specified in many places in the API. Whenever you see the term PATH_SPECIFIER, the path can be specified as one of the following:

    * a string specifying either a full path or a relative path. If only a relative path is provided, it will be be interpreted relative to the bundle directory if it is evaluated at _command definition_ time, and relative to the command's working directory if it is evaluated at _command invocation_ time (the latter is more common).
    * an object that will return a path string as defined directly above when its @to_s@ method is called (e.g. @File@ or @Dir@)
    * a Ruby @symbol@ with special meaning. For example, @:current_project@ might refer to the currently loaded project (NOT YET IMPLEMENTED)

h2. INPUT_SPECIFIER

The possible input specifiers are:

| @:selection@			| selected text in the editor |
| @:left_character@		| the character to the immediate left of the caret |
| @:right_character@	| the character to the immediate right of the caret |
| @:word@				| word surrounding the current caret |
| @:line@				| the line containing the caret |
| @:document@			| the entire current document |
| @:clipboard@			| the contents of the clipboard |
| @:scope@				| (NOT YET IMPLEMENTED) As in TextMate: search backwards and forwards for the first character which is not matched by the scope selector of the command and use those as boundaries for the input. |
| @:input_from_console@	| take input from a shell window? How do we specify which console? |
| @:none@				| no input is needed by this command. When encountered in the *multiple symbol specifier* case, this symbol always terminates fallback evaluation |
| @:selected_lines@		| I'm not sure what this does or how it differs from :selection!!! |

h2. OUTPUT_SPECIFIER

The possible output specifiers are:

| @:insert_as_text@	| insert text at the caret position. If there is a selection, the text is inserted immediately following the selection and the selection is lost. |
| @:insert_as_snippet@	| as with @:insert_as_text@, but the output is interpreted as snippet expansion text |
| @:replace_selection@	| replace the currently selected text with the output. If no text is selected, this is equivalent to the @:insert_as_text@ specifier |
| @:replace_document@	| replace the entire document with the output |
| @:copy_to_clipboard@	| replace the contents of the clipboard with the output |
| @:show_as_html@	| open an html browser window and intepret the output as html |
| @:show_as_tooltip@	| show a tooltip containing the output |
| @:create_new_document@	| create a new editor document containing the output |
| @:output_to_console@	| display the output in a console. HOW DO WE SPECIFY WHICH CONSOLE |
| @:discard@	| throw any output away |
| @:replace_selected_lines@	| what does this do? probably unnecessary |
| @:replace_line@	| replace the line around the caret. probably unnecessary |
| @:replace_word@	| replace the word around the caret. probably unnecessary |

h1. Bundle.rb

As discussed in the _Runtime Architecture_ section above, the @bundle.rb@ file defines the metadata and menus for the bundle. This section specifies these items in more detail.

h2. Metadata

Bundles have metadata associated with them. The following properties are pre-defined:

| @name@		| the user-visible name of the bundle. E.g, "Ruby on Rails". This name will be shown in menus, error messages, and so forth.|
| @description@	| a longer, textual description of the bundle and its purpose|
| @author@		| the author(s) of the bundle|
| @copyright@	| any copyright message associated with the bundle|
| @license@		| the name or URL of the license associated with the bundle. E.g. "MIT License" or "http://www.gnu.org/licenses/gpl-3.0.txt"|
| @website@		| the website where more information about the bundle can be found|
| @repository@	| the public repository url where the canonical version of this bundle lives. E.g. "git://github.com/aptana/rrbundle_rails.git"|

Additional properties can be accessed, though, simply by referring to them as though they already exist, e.g.:

bc. bundle.foo = "bar"

h2. Menus

A bundle may define one or more menus to expose its commands and snippets to the user. Most bundles will only define a single menu. RadRails shows these menus in a number of places. First and foremost, it shows up in the main menu underneath the 'Commands' menu. It also shows up in the right-click context menu of editor windows.

A menu is a container for commands, sub-menus, and separators. Commands are specified by their names, with all other information coming from the command itself (e.g., its @key_binding@ or @trigger@). As discussed earlier, these names are scoped to the current bundle.

Menus also have a scope, which defines the contexts in which the entire menu is applicable. We interpret the scopes for menus more loosely than we do for commands, erring to show the menu more often than not. And the Commands menu will still show your menu in the "Other" submenu of the Commands menu even if your scope operator doesn't match. Note that while you can define a scope for a sub-menu, but it is currently ignored.

h2. Sample bundle.rb File

The following is a real but extremely minimal bundle.rb file which defines a 'Rails' menu which in turn contains only a single 'Go To' submenu.

<pre>
<code programming-language="ruby">
require 'radrails'

RadRails.current_bundle do |bundle|
  bundle.name = "Ruby on Rails"
  bundle.author = "Many"
  bundle.repository = "git://github.com/aptana/rrbundle_rails.git"

  bundle.menu "Rails" do |rails_menu|
    # this menu should be shown when any of the following scopes is active:
    rails_menu.scope = [ "source.ruby", "project.rails" ]

    rails_menu.menu "Go To" do |goto_menu|
      goto_menu.command "Go to File on Current Line"
      goto_menu.separator
      goto_menu.command "Go to Model"
	  # etc....
    end
end
</code>
</pre>

h1. Commands and Snippets

As discussed in the _Runtime Architecture_ section above, commands and snippets are the backbone of the bundle runtime. This section lays out the definition and invocation of commands and snippets in more detail.

h2. Key Bindings

A command can optionally have one or more key bindings associated with it. These key bindings are specified using one of the following forms:

If there is only one key binding associated with the command:

bc. command.key_binding = KEY_SEQUENCE

Examples:

bc. command.key_binding = "CONTROL+T" # Single key stroke key binding

bc. command.key_binding = "M1+M3+Q C" # Multiple key stroke key binding

If there are more than one key bindings associated with the command, an array of key binding sequences can be specified.

bc. command.key_binding = [ KEY_SEQUENCE, KEY_SEQUENCE, etc. ]

Example:

bc. command.key_binding = [ "M1+W", "M1+F4" ] # Multiple keybindings for same command

The KEY_SEQUENCE syntax follows the Eclipse conventions, since those are more portable than the ones used in TextMate. A KEY_SEQUENCE should consist of one or more key strokes. Key strokes are separated by spaces. A key stroke consists of one or more keys held down at the same time. This should be zero or more modifier keys, and one other key. The keys are separated by the + character. The recognized modifiers keys are ALT or OPTION, COMMAND, CTRL, and SHIFT. In addition M1, M2, M3, M4 modifier keys are also recognized. The "M" modifier keys are a platform-independent way of representing keys, and these are generally preferred. M1 is the COMMAND key on MacOS X, and the CTRL key on most other platforms. M2 is the SHIFT key. M3 is the Option key on MacOS X, and the ALT key on most other platforms. M4 is the CTRL key on MacOS X, and is undefined on other platforms. Since M2+M3+<Letter> (Alt+Shift+<Letter>) is reserved on MacOS X for writing special characters.

The actual key is generally specified simply as the ASCII character, in uppercase. So, for example F or X, are examples of such keys. However, there are some special keys; keys that have no printable ASCII representation. The following is a list of the current special keys: 

| ARROW_DOWN	| F1	| NUMPAD_0	|
| ARROW_LEFT	| F2	| NUMPAD_1	|
| ARROW_RIGHT	| F3	| NUMPAD_2	|
| ARROW_UP	| F4	| NUMPAD_3	|
| BREAK	| F5	| NUMPAD_4	|
| BS	| F6	| NUMPAD_5	|
| CAPS_LOCK	| F7	| NUMPAD_6	|
| CR	| F8	| NUMPAD_7	|
| DEL	| F9	| NUMPAD_8	|
| END	| F10	| NUMPAD_9	|
| ESC	| F11	| NUMPAD_ADD	|
| HOME	| F12	| NUMPAD_DECIMAL	|
| INSERT	| F13	| NUMPAD_DIVIDE	|
| LF	| F14	| NUMPAD_ENTER	|
| FF	| F15	| NUMPAD_EQUAL	|
| NUL	| PRINT_SCREEN	| NUMPAD_MULTIPLY	|
| PAGE_UP	| PAUSE	| NUMPAD_SUBTRACT	|
| PAGE_DOWN	| SCROLL_LOCK	| NUM_LOCK	|
| SPACE	| TAB	| VT	|

Alternate names for some common special keys are also allowed. For example, ESC/ESCAPE, and CR/ENTER/RETURN are synonyms.

We strongly recommend against the use of SHIFT or M2 without including another CONTROL_KEY_SPECIFIER, as the results can be unpredictable.

It is possible for commands to define specific key bindings for specific platforms. To enable this, the @key_binding@ property supports hash-table style access for setting platform specific key bindings. Platform-specific bindings always take precedence over the generic binding. See the example below:

<pre>
<code programming-language="ruby">
command.key_binding = "CONTROL+V"
command.key_binding[:mac] = "COMMAND+V" ]
</code>
</pre>

Supported platform identifiers are @:mac@, @:windows@, @:linux@, and @:unix@. The @:unix@ identifier will match Linux, BSD, Solaris, and most other unix-like OSes (except the Mac).

h2. Input Definition

Commands can take their input from a variety of different sources, or a combination of those sources. This makes it very easy to create commands that can process input from editors without writing a bunch of if/then statements within your command.

Inputs can be specified using the *single input specifier* form:

bc. command.input = INPUT_SPECIFIER

or the *multiple input specifier* form:

bc. command.input = [ INPUT_SPECIFIER, INPUT_SPECIFIER, etc. ]

or the *path specifier* form:

bc. command.input = PATH_SPECIFIER

In the *multiple input specifier* form, each @INPUT_SPECIFIER@ is processed in order until a valid @INPUT_SPECIFIER@ was found. So if, for example, the command specified:

bc. cmd.input = [ :selection, :word ]

Then the @:selection@ specifier would be checked to see if it evaluated to a non-empty value. If it did not have such a value, the @:word@ specifier would be checked. If the caret was not within a valid word, then the command would be invoked with a nil input.

h2. Output Definition

As with input, commands may wish to generate output in a number of different ways. In RadRails, output can be specified using the *single output specifier* form:

bc. command.output = OUTPUT_SPECIFIER

or the *path specifier* form:

bc. command.output = PATH_SPECIFIER

As with the input specifier, the *path specifier* form allows you to define a filename or other stream specifier to write the output to.

h2. Invocation and Context

h3. Context During Command Invocation

When a command's @invoke@ property is set a ruby block, that block is passed a @context@ object as an argument. The context object has the following properties:

| @input@		| The input to the command, typically as a string. See the _Input During Command Invocation_ section below. |
| @ouput@		| The output of the command, typically an output stream. See the _Output During Command Invocation_ section below. |
| @invoked_via@	| How the command was invoked. Can be @:key_binding@, @:menu@, @:unknown@, @:command@, or a trigger string. |
| @command@		| The Command object being executed. |
| @bundle@		| The Bundle in which the command is defined. |
| @scope@		| The Scope in which the command was executed. |
| @file@		| The File currently being edited, or nil |
| @project@		| The Project that owns the file currently being edited, or nil. See _Project API_ for more information. |
| @explorer@	| The app explorer. See _Project API_ for more information. |
| @stdout@		| Stream useful for writing output to stdout. See the _Output During Command Invocation_ section below. |
| @stderr@		| Stream useful for writing error output. See the _Output During Command Invocation_ section below. |
| @line_number@	| The starting line number of @input@, numbered starting with 1. |
| @line_index@	| The starting position on the line of @input@, numbered from 0. |
| @soft_tabs@	| Boolean indicating whether or not soft tabs are being used for the current file. |
| @tab_size@	| Tab width for the current file. |

In addition, the context has a few handy-dandy functions for use by commands, as described below:

| @exit_with_message(message, OUTPUT_SPECIFIER)@	| Short-circuit the execution of the command, using the specified OUTPUT_SPECIFIER |
| @invoke(name, INVOKE_OPTIONS)@ | Invoke another command or snippet by name, and return its context object so that its output and other properties can be extracted. NOT YET IMPLEMENTED. |

h4. INVOKE_OPTIONS

You can supply additional options to the @invoke@ method via its INVOKE_OPTIONS hash. These options effect the state of the context object passed to the command when it is invoked:

| @:input@		| If specified, the context's @input@ property will be set to this value. This is useful when you want your command to process user input and then have another command further process that input. If it is not defined the INPUT_SPECIFIER in the command's definition will be used as normal. |
| @:ouput@		| If specified, this OUTPUT_SPECIFIER overrides the one defined by the command. |
| @:scope@		| The scope specifier to be passed to the command |
| @:bundle@		| If specified, look for the command to invoke in the named bundle instead of the current bundle. |

h3. Input During Command Invocation

If a command is defined to invoke a shell script, the command supplies the input text on @stdin@ and as "environment variables":http://manual.macromates.com/en/environment_variables.html, for compatibility with TextMate.

If a command is defined to invoke an inline Ruby block, the input is passed to the block via its context argument as described in _Context During Command Invocation_ above. The @input@ property can be treated as a simple string, but the method has a few extra methods which can be used for processing input as a stream:

| @is_stream?@ | returns true if the input is coming from a file or other stream |
| @to_stream@ | returns the underlying stream object, or nil if is_stream? returns false |

h3. Output During Command Invocation

By default, any output to @stdout@ during command invocation is treated as the output of the command. If the command is defined to invoke a ruby inline block, the context variable passed to the block can also be used to set the output value directly via the @output@ property of the context:

bc. context.output = "foo"

There are also @stderr@ and @stdout@ properties on the context object that contain the streams used during command invocation. They cannot be re-assigned by the block. When the context is first passed to the command, @output@ and @stdout@ will be set to the same value.

Output written to @stderr@ during command execution will be displayed in the Console. Output written to @stdout@ will also be written to the Console if the command block changes the value of @output@.

h1. Project API

Project objects have the following properties and methods:

| @name@						| The name of the project. Usually the basename of the root project directory. |
| @exists?@						| True if the project exists on disk. |
| @to_dir@						| Returns the @Dir@ corresponding to the project's root |
| @refresh(shallow = false)@	| Forces a refresh of the project. Pass in true to force only a shallow refresh of the project and direct members |
| @is_open?@					| Returns true if the project is open. |
| @is_closed?@					| Opposite of @is_open?@ |
| @open@						| If the project isn't currently open, open it. |
| @close@						| Close the project |
| @make_current@				| Make the project the current/active one highlighted by the App Explorer |
| @rails?@						| Query method to tell if a project has a rails nature |

There are also a number of useful static methods defined on the RadRails::Project class that can be useful in ruby code outside of a command:

| @find(name)@							| Find the named project in the workspace |
| @all@									| Return all projects in an array |
| @create(name, PROJECT_OPTIONS = {})@	| Create a new project with the given name and PROJECT_OPTIONS |
| @current@								| Returns the "current"/"active" project |

h2. PROJECT_OPTIONS

FORTHCOMING

h1. Browser API (NOT YET IMPLEMENTED)

Currently the Browser object only supports a single method:

| @open(url, OPTIONS_SPECIFIER)@ | Open a new browser pointed at the specified @url@, using the options in the OPTIONS_SPECIFIER hash. |

h2. OPTIONS_SPECIFIER

All the options are, as the name implies, optional.

| @:new_window@	| Boolean which specifies whether or not to open a new browser window (tab) or not. The default is @false@, which will re-use the last browser window opened if possible. |
| @:title@		| The title of the browser window. Can be overridden by the HTML within the browser window. |
